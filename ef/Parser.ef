type ParseSuccess(tree, tail)
type ParseFailure

type BinaryExpr(left, op, right)
type Not(tree)
type MethodCall(typeName, methodName, argsInvocation)
type ArgsInvocation(args)
type IsA(expr, testType)

parseExpression(tokens) ->:
  return _parseUnaryOp(tokens)

_parseUnaryOp(tokens) ->:
  if tokens is:
    Queue(KwNot, @tokens):
      return if _parseUnaryOp(tokens) is:
        ParseSuccess(expression, @tokens): ParseSuccess(Not(expression), tokens)
        err: err
    *:
      return _parseComparisons(tokens)
    
_parseComparisons(tokens) ->:
  if _parseTerms(tokens) is:
    ParseSuccess(term, @tokens):
      while tokens is Queue(op if _isCmpOp(op), @tokens):
        if _parseTerms(tokens) is:
          ParseSuccess(rhs, @tokens):
            term = BinaryExpr(term, op, rhs)
          err:
            return err
      return ParseSuccess(term, tokens)
    err:
      return err

_parseTerms(tokens) ->:
  if _parseFactors(tokens) is:
    ParseSuccess(term, @tokens):
      while tokens is Queue(op if _isTermOp(op), @tokens):
        if _parseFactors(tokens) is:
          ParseSuccess(rhs, @tokens):
            term = BinaryExpr(term, op, rhs)
          err:
            return err
      return ParseSuccess(term, tokens)
    err:
      return err

_parseFactors(tokens) ->:
  if _parseIsExpr(tokens) is:
    ParseSuccess(term, @tokens):
      while tokens is Queue(op if _isFactorOp(op), @tokens):
        if _parseIsExpr(tokens) is:
          ParseSuccess(rhs, @tokens):
            term = BinaryExpr(term, op, rhs)
          err:
            return err
      return ParseSuccess(term, tokens)
    err:
      return err

_parseIsExpr(tokens) ->:
    return if _parseSimpleExpression(tokens) is:
      ParseSuccess(expr, Queue(KwIs, Queue(KwNot, Queue(IdentType(t), @tokens)))): ParseSuccess(Not(IsA(expr, t)), tokens)
      ParseSuccess(expr, Queue(KwIs, Queue(IdentType(t), @tokens))): ParseSuccess(IsA(expr, t), tokens)
      err: err

_isCmpOp(op) ->:
  return if op is:
    KwEq: True
    KwGe: True
    KwGt: True
    KwLe: True
    KwLt: True
    KwNe: True
    *: False

_isTermOp(op) ->:
  return if op is:
    KwPlus: True
    KwDash: True
    *: False

_isFactorOp(op) ->:
  return if op is:
    KwAsterisk: True
    KwSlash: True
    *: False

_parseSimpleExpression(tokens) ->:
  # Rules that don't have to worry about order of operations.
  # These are rules that are unambiguous. For instance, "123" is just an IntLiteral, and foo(123)
  # is unambiguously an invocation of foo with 123 as its arg.
  if tokens is:
    Queue(head, @tokens):
      if head is: # TODO should I inline these? "return if head is..."
        e IntLiteral(*):
          return ParseSuccess(e, tokens)
        e StringLiteral(*):
          return ParseSuccess(e, tokens)
        KwThis:
          return ParseSuccess(KwThis, tokens)
        IdentType(t):
          if _argsInvocation(tokens) is:
            ParseSuccess(args, @tokens):
              call = MethodCall(t, t, args)
              return ParseSuccess(call, tokens)
            err:
              return err
        KwParenOpen:
          if parseExpression(tokens) is:
            ParseSuccess(e, Queue(KwParenClose, @tokens)):
              return ParseSuccess(e, tokens)
            err:
              return err
        *:
          return ParseFailure
    *:
      return ParseFailure

_argsInvocation(tokens) ->:
  # TODO this method's indentation shows just how much we need exception
  args = Empty
  if tokens is:
    Queue(KwParenOpen, @tokens):
      if tokens is not Queue(KwParenClose, @tokens):
        if parseExpression(tokens) is:
          ParseSuccess(arg, @tokens):
            args = Queue.push(args, arg)
            while tokens is:
              Queue(KwComma, @tokens):
                if parseExpression(tokens) is:
                  ParseSuccess(arg, @tokens):
                    args = Queue.push(args, arg)
                  err:
                    return err
              Queue(KwParenClose, @tokens):
                break
  args = Queue.reverse(args)
  call = ArgsInvocation(args)
  return ParseSuccess(call, tokens)

main(args) ->:
  tokens = Tokens.readTokens(Stdio.stdin)
  ::: args is Array
  result = Empty
  if args.get(0) is:
    ~/expression$/:
      result = parseExpression(tokens)
  CharStreamOut.debugPretty(result)
  return 0
