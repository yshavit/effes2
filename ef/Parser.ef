type ParseSuccess(tree, tail)
type ParseFailure

type BinaryExpr(left, op, right)
type Not(tree)
type Instantiation(typeName, args)
type UnqualifiedMethodCall(name, args)
type StaticMethodCall(typeName, methodName, args)
type QualifiedMethodCall(target, name, args)
type ArgsInvocation(args)
type IsA(expr, testType)
type PlainVar(name)
type QualifiedVar(target, name)
type StaticVar(typeName, varName)

parseExpression(tokens) ->:
  return _parseUnaryOp(tokens)

_parseUnaryOp(tokens) ->:
  if tokens is:
    Queue(KwNot, @tokens):
      return if _parseUnaryOp(tokens) is:
        ParseSuccess(expression, @tokens): ParseSuccess(Not(expression), tokens)
        err: err
    *:
      return _parseComparisons(tokens)
    
_parseComparisons(tokens) ->:
  if _parseTerms(tokens) is:
    ParseSuccess(term, @tokens):
      while tokens is Queue(op if _isCmpOp(op), @tokens):
        if _parseTerms(tokens) is:
          ParseSuccess(rhs, @tokens):
            term = BinaryExpr(term, op, rhs)
          err:
            return err
      return ParseSuccess(term, tokens)
    err:
      return err

_parseTerms(tokens) ->:
  if _parseFactors(tokens) is:
    ParseSuccess(term, @tokens):
      while tokens is Queue(op if _isTermOp(op), @tokens):
        if _parseFactors(tokens) is:
          ParseSuccess(rhs, @tokens):
            term = BinaryExpr(term, op, rhs)
          err:
            return err
      return ParseSuccess(term, tokens)
    err:
      return err

_parseFactors(tokens) ->:
  if _parseIsExpr(tokens) is:
    ParseSuccess(term, @tokens):
      while tokens is Queue(op if _isFactorOp(op), @tokens):
        if _parseIsExpr(tokens) is:
          ParseSuccess(rhs, @tokens):
            term = BinaryExpr(term, op, rhs)
          err:
            return err
      return ParseSuccess(term, tokens)
    err:
      return err

_parseIsExpr(tokens) ->:
    return if _parseSimpleExpression(tokens) is:
      ParseSuccess(expr, Queue(KwIs, Queue(KwNot, Queue(IdentType(t), @tokens)))): ParseSuccess(Not(IsA(expr, t)), tokens)
      ParseSuccess(expr, Queue(KwIs, Queue(IdentType(t), @tokens))): ParseSuccess(IsA(expr, t), tokens)
      err: err

_isCmpOp(op) ->:
  return if op is:
    KwEq: True
    KwGe: True
    KwGt: True
    KwLe: True
    KwLt: True
    KwNe: True
    *: False

_isTermOp(op) ->:
  return if op is:
    KwPlus: True
    KwDash: True
    *: False

_isFactorOp(op) ->:
  return if op is:
    KwAsterisk: True
    KwSlash: True
    *: False

_parseSimpleExpression(tokens) ->:
  # Rules that don't have to worry about order of operations.
  # These are rules that are unambiguous. For instance, "123" is just an IntLiteral, and foo(123)
  # is unambiguously an invocation of foo with 123 as its arg.
  if tokens is:
    Queue(head, @tokens):
      if head is: # TODO should I inline these? "return if head is..."
        e IntLiteral(*):
          return ParseSuccess(e, tokens)
        e StringLiteral(*):
          return ParseSuccess(e, tokens)
        KwThis:
          # First, look for "this.var" -- either an instance method or instance var
          if tokens is Queue(KwDot, Queue(IdentName(n), @tokens)):
            if _argsInvocation(tokens) is:
              ParseSuccess(Empty, @tokens):
                return ParseSuccess(QualifiedVar(KwThis, n), tokens)
              ParseSuccess(args, @tokens):
                return ParseSuccess(QualifiedMethodCall(KwThis, n, args), tokens)
              *:
                return ParseFailure
          return ParseSuccess(KwThis, tokens)
        IdentType(t):
          # First, look for "Foo.var" -- either a static method or a static var
          if tokens is Queue(KwDot, Queue(IdentName(n), @tokens)):
            if _argsInvocation(tokens) is:
              ParseSuccess(Empty, @tokens):
                return ParseSuccess(StaticVar(t, n), tokens)
              ParseSuccess(args, @tokens):
                return ParseSuccess(StaticMethodCall(t, n, args), tokens)
              *:
                return ParseFailure
          # Otherwise, look for "Foo(arg)" -- an instantiation
          if _argsInvocation(tokens) is:
            ParseSuccess(args, @tokens):
              if args is Empty:
                args = ArgsInvocation(Empty) # "Foo" -> "Foo()", just to normalize it
              call = Instantiation(t, args)
              return ParseSuccess(call, tokens)
            err:
              return err
        IdentName(n):
          # "var" -- so either a var or method invocation
          if _argsInvocation(tokens) is:
            ParseSuccess(Empty, @tokens):
              return ParseSuccess(PlainVar(n), tokens)
            ParseSuccess(args, @tokens):
              return ParseSuccess(UnqualifiedMethodCall(n, args), tokens)
            *:
              return ParseFailure
        KwParenOpen:
          if parseExpression(tokens) is:
            ParseSuccess(e, Queue(KwParenClose, @tokens)):
              return ParseSuccess(e, tokens)
            err:
              return err
        *:
          return ParseFailure
    *:
      return ParseFailure

_argsInvocation(tokens) ->:
  # TODO this method's indentation shows just how much we need exception
  if tokens is:
    Queue(KwParenOpen, @tokens):
      args = Empty
      if tokens is not Queue(KwParenClose, @tokens):
        if parseExpression(tokens) is:
          ParseSuccess(arg, @tokens):
            args = Queue.push(args, arg)
            while tokens is:
              Queue(KwComma, @tokens):
                if parseExpression(tokens) is:
                  ParseSuccess(arg, @tokens):
                    args = Queue.push(args, arg)
                  err:
                    return err
              Queue(KwParenClose, @tokens):
                break
      args = Queue.reverse(args)
      call = ArgsInvocation(args)
      return ParseSuccess(call, tokens)
    *:
      return ParseSuccess(Empty, tokens)

main(args) ->:
  tokens = Tokens.readTokens(Stdio.stdin)
  ::: args is Array
  result = Empty
  if args.get(0) is:
    ~/expression$/:
      result = parseExpression(tokens)
  CharStreamOut.debugPretty(result)
  return 0
