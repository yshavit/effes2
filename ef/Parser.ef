import Lexer: *

type EfFile(types)
type EfType(name, args)
type NoParse
type _Parsed(element, remainingTokens)

readTokens(lexer) -> :
  toks = Empty
  while lexer.next() is:
    False:
      return reverse(toks)
    tok:
      toks = Cons(tok, toks)

parseFile(toks) -> :
  types = Empty
  methods = Empty
  while toks is not Empty:
    if parseType(toks) is _Parsed(elem, @toks):
      types = Cons(elem, types)
    elif parseMethod(toks) is _Parsed(elem, @toks):
      methods = Cons(elem, methods)
    else:
      return NoParse
  types = reverse(types)
  methods = reverse(methods)
  return EfFile(types)

parseType(toks) -> :
  if toks is:
    Cons(Cons(KwType, Identifier(name)), @toks):
      args = Empty
      if parseArgs(toks) is _Parsed(@args, @toks):
        ::
      if toks is:
        Cons(Newline,@toks):
          return _Parsed(EfType(name, args), toks)
    *:
      return NoParse

parseMethod(toks) -> :
  return NoParse # TODO!

parseArgs(toks) -> :
  if toks is:
    Cons(OpenParen, Cons(CloseParen, @toks)):
      return _Parsed(Empty, toks)
    Cons(OpenParen, @toks):
      # We'll be evaluating the rule: '(' name (',' name)* ')'
      # As such, we first pick the first name, and then parse
      # comma-name as many times as we can.
      names = Empty
      if toks is:
        Cons(Identifier(name), @toks):
          names = Cons(name, Empty)
        *:
          return NoParse
      while toks is:
        Cons(CloseParen, @toks):
          names = reverse(names) # Cons pushes to back-to-front, we want front-to-back
          return _Parsed(names, toks)
        Cons(Comma, Cons(Identifier(name), @toks))
          names = Cons(name, names)
        *:
          return NoParse
    *:
    return NoParse

main(args) -> :
  Stdout.print(parseFile(readTokens(Lexer.create(Stdin))))
  return 0
