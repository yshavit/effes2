type ParseSuccess(tree, tail)
type ParseFailure

type BinaryExpr(left, op, right)
type Not(tree)
type Instantiation(typeName, args)
type UnqualifiedMethodCall(name, args)
type StaticMethodCall(typeName, methodName, args)
type QualifiedMethodCall(target, name, args)
type ArgsInvocation(args)
type IsA(expr, matcher)
type PlainVar(name)
type QualifiedVar(target, name)
type StaticVar(typeName, varName)

type RebindVar(name) # for "@foo" in matchers
type MatcherAny
type MatcherJustName(bindTo, condition) # condition is "True" if no condition given
type MatcherWithPattern(bindTo, pattern)
type PatternType(typeName, args)

parseExpression(tokens) ->:
  return _parseUnaryOp(tokens)

_parseUnaryOp(tokens) ->:
  if tokens is:
    Queue(KwNot, @tokens):
      return if _parseUnaryOp(tokens) is:
        ParseSuccess(expression, @tokens): ParseSuccess(Not(expression), tokens)
        err: err
    *:
      return _parseComparisons(tokens)
    
_parseComparisons(tokens) ->:
  if _parseTerms(tokens) is:
    orig ParseSuccess(lhs, @tokens):
      if tokens is:
        Queue(op if _isCmpOp(op), @tokens):
          return if _parseTerms(tokens) is:
            ParseSuccess(rhs, @tokens): ParseSuccess(BinaryExpr(lhs, op, rhs), tokens)
            err: err
        *:
          return orig
    err:
      return err

_parseTerms(tokens) ->:
  if _parseFactors(tokens) is:
    ParseSuccess(term, @tokens):
      while tokens is Queue(op if _isTermOp(op), @tokens):
        if _parseFactors(tokens) is:
          ParseSuccess(rhs, @tokens):
            term = BinaryExpr(term, op, rhs)
          err:
            return err
      return ParseSuccess(term, tokens)
    err:
      return err

_parseFactors(tokens) ->:
  if _parseIsExpr(tokens) is:
    ParseSuccess(term, @tokens):
      while tokens is Queue(op if _isFactorOp(op), @tokens):
        if _parseIsExpr(tokens) is:
          ParseSuccess(rhs, @tokens):
            term = BinaryExpr(term, op, rhs)
          err:
            return err
      return ParseSuccess(term, tokens)
    err:
      return err

_parseIsExpr(tokens) ->:
  if _parseSimpleExpression(tokens) is:
    ParseSuccess(expr, Queue(KwIs, @tokens)):
      negated = tokens is Queue(KwNot, @tokens)
      if _parseMatcher(tokens) is:
        ParseSuccess(matcher, @tokens):
          result = IsA(expr, matcher)
          if negated:
            result = Not(result)
          return ParseSuccess(result, tokens)
        err:
          return err
    err:
      return err

_isCmpOp(op) ->:
  return if op is:
    KwEq: True
    KwGe: True
    KwGt: True
    KwLe: True
    KwLt: True
    KwNe: True
    *: False

_isTermOp(op) ->:
  return if op is:
    KwPlus: True
    KwDash: True
    *: False

_isFactorOp(op) ->:
  return if op is:
    KwAsterisk: True
    KwSlash: True
    *: False

_parseSimpleExpression(tokens) ->:
  # Rules that don't have to worry about order of operations.
  # These are rules that are unambiguous. For instance, "123" is just an IntLiteral, and foo(123)
  # is unambiguously an invocation of foo with 123 as its arg.
  if tokens is:
    Queue(head, @tokens):
      if head is: # TODO should I inline these? "return if head is..."
        e IntLiteral(*):
          return ParseSuccess(e, tokens)
        e StringLiteral(*):
          return ParseSuccess(e, tokens)
        KwThis:
          # First, look for "this.var" -- either an instance method or instance var
          if tokens is Queue(KwDot, Queue(IdentName(n), @tokens)):
            return if _argsInvocation(tokens) is:
              ParseSuccess(Empty, @tokens): ParseSuccess(QualifiedVar(KwThis, n), tokens)
              ParseSuccess(ArgsInvocation(args), @tokens): ParseSuccess(QualifiedMethodCall(KwThis, n, args), tokens)
              *: ParseFailure
          return ParseSuccess(KwThis, tokens)
        IdentType(t):
          # First, look for "Foo.var" -- either a static method or a static var
          if tokens is Queue(KwDot, Queue(IdentName(n), @tokens)):
            return if _argsInvocation(tokens) is:
              ParseSuccess(Empty, @tokens): ParseSuccess(StaticVar(t, n), tokens)
              ParseSuccess(ArgsInvocation(args), @tokens): ParseSuccess(StaticMethodCall(t, n, args), tokens)
              *: ParseFailure
          # Otherwise, look for "Foo(arg)" -- an instantiation
          return if _argsInvocation(tokens) is:
            ParseSuccess(Empty, @tokens): ParseSuccess(Instantiation(t, Empty), tokens)
            ParseSuccess(ArgsInvocation(args), @tokens): ParseSuccess(Instantiation(t, args), tokens)
            err: err
        IdentName(n):
          # "var" -- so either a var or method invocation
          return if _argsInvocation(tokens) is:
            ParseSuccess(Empty, @tokens): ParseSuccess(PlainVar(n), tokens)
            ParseSuccess(ArgsInvocation(args), @tokens): ParseSuccess(UnqualifiedMethodCall(n, args), tokens)
            *: ParseFailure
        KwParenOpen:
          return if parseExpression(tokens) is:
            ParseSuccess(e, Queue(KwParenClose, @tokens)): ParseSuccess(e, tokens)
            err: err
        *:
          return ParseFailure
    *:
      return ParseFailure

_argsInvocation(tokens) ->:
  # TODO this method's indentation shows just how much we need exception
  if tokens is:
    Queue(KwParenOpen, @tokens):
      args = Empty
      if tokens is:
        Queue(KwParenClose, @tokens):
          :::
        *:
          if parseExpression(tokens) is:
            ParseSuccess(arg, @tokens):
              args = Queue.push(args, arg)
              while tokens is:
                Queue(KwComma, @tokens):
                  if parseExpression(tokens) is:
                    ParseSuccess(arg, @tokens):
                      args = Queue.push(args, arg)
                    err:
                      return err
                Queue(KwParenClose, @tokens):
                  break
      args = Queue.reverse(args)
      call = ArgsInvocation(args)
      return ParseSuccess(call, tokens)
    *:
      return ParseSuccess(Empty, tokens)

_parseMatcher(tokens) ->:
  if tokens is Queue(KwAsterisk, @tokens):
    return ParseSuccess(KwAsterisk, tokens)
  if _parseBindTo(tokens) is:
    ParseSuccess(bindTo, @tokens):
      # Could be "var <matcherWithPattern>", or "var", or "var if cond"
      if tokens is:
        Queue(KwIf, @tokens):
          return if parseExpression(tokens) is:
            ParseSuccess(cond, @tokens): ParseSuccess(MatcherJustName(bindTo, cond), tokens)
            err: err
        *:
          return if _parseMatcherPattern(tokens) is:
            ParseSuccess(pattern, @tokens): ParseSuccess(MatcherWithPattern(bindTo, pattern), tokens)
            *: ParseSuccess(MatcherJustName(bindTo, True), tokens)
    *:
      # It can't be a "foo" or "foo if cond", but it can still be a MatcherWithPattern.
      if _parseMatcherPattern(tokens) is:
        ParseSuccess(pattern, @tokens):
          return ParseSuccess(MatcherWithPattern(Empty, pattern), tokens)
        err:
          return err

_parseBindTo(tokens) ->:
  return if tokens is:
    Queue(KwAt, Queue(IdentName(n), @tokens)): ParseSuccess(RebindVar(n), tokens)
    Queue(IdentName(n), @tokens): ParseSuccess(PlainVar(n), tokens)
    err: err

_parseMatcherPattern(tokens) ->:
  if tokens is:
    Queue(r RegexLiteral(*), @tokens):
      return ParseSuccess(r, tokens)
    Queue(IdentType(t), @tokens):
      if tokens is:
        Queue(KwParenOpen, @tokens):
          if _parseMatcher(tokens) is:
            ParseSuccess(matcher, @tokens):
              args = Queue(matcher, Empty)
              while tokens is:
                Queue(KwComma, @tokens):
                  if _parseMatcher(tokens) is:
                    ParseSuccess(nextMatcher, @tokens):
                      args = Queue.push(args, nextMatcher)
                    err:
                      return err
                Queue(KwParenClose, @tokens):
                  args = Queue.reverse(args)
                  return ParseSuccess(PatternType(t, args), tokens)
            err:
              return err
        *:
          return ParseSuccess(PatternType(t, Empty), tokens)
    err:
      return err


main(args) ->:
  tokens = Tokens.readTokens(Stdio.stdin)
  ::: args is Array
  result = Empty
  if args.get(0) is:
    ~/expression$/:
      result = parseExpression(tokens)
    ~/matcher$/:
      result = _parseMatcher(tokens)
  CharStreamOut.debugPretty(result)
  return 0
