import Lexer: *

type EfFile(types, methods)
type EfType(name, args)
type EfMethod(name, args, hasRv, statements)
# statements
# KwReturn, with no value
type EfStatAssign(name, expr)

# expressions
type CtorCall(typeName, args)

type NoParse
type _Parsed(element, remainingTokens)

readTokens(lexer) -> :
  toks = Empty
  while lexer.next() is:
    False:
      return reverse(toks)
    tok:
      toks = Cons(tok, toks)

parseFile(toks) -> :
  types = Empty
  methods = Empty
  while toks is not Empty:
    if parseType(toks) is _Parsed(elem, @toks):
      types = Cons(elem, types)
    elif parseMethod(toks) is _Parsed(elem, @toks):
      methods = Cons(elem, methods)
    else:
      return NoParse
  types = reverse(types)
  methods = reverse(methods)
  return EfFile(types, methods)

parseType(toks) -> :
  if toks is:
    Cons(Cons(KwType, TypeName(name)), @toks):
      args = Empty
      if parseArgs(toks) is _Parsed(@args, @toks):
        :::
      if toks is:
        Cons(Newline,@toks):
          return _Parsed(EfType(name, args), toks)
    *:
      return NoParse

parseMethod(toks) -> :
  if toks is not Cons(Identifier(@name), @toks):
    return NoParse
  if parseArgs(toks) is not _Parsed(args, @toks):
    return NoParse
  hasRv = if toks is:
    Cons(Arrow, @toks): True
    *: False
  if toks is not Cons(Colon, @toks):
    return NoParse
  if parseBlock(toks) is not _Parsed(@statements, @toks):
    return NoParse
  return _Parsed(EfMethod(name, args, hasRv, statements), toks)

parseBlock(toks) -> :
  if toks is not Cons(Indent, @toks):
    return NoParse
  statements = Empty
  while toks is:
    Cons(Dedent, @toks):
      return _Parsed(reverse(statements), toks)
    *:
      if parseStatement(toks) is _Parsed(s, @toks):
        s = Cons(s, statements)
      else:
        return NoParse

parseStatement(toks):
  s = ?
  # return
  if toks is Cons(KwReturn, @toks):
    s = KwReturn
  # assignment
  elif toks is Cons(Identifier(@name), Cons(Equals, @toks)):
    if parseExpression(toks) is _Parsed(@expr, @toks):
      s = EfStatAssign(name, expr)
    else:
      return NoParse
  else:
    return NoParse

  if toks is Cons(Newline, @toks):
    return _Parsed(s, toks)
  else:
    return NoParse

parseExpression(toks) -> :
  # ctor
  if toks is Cons(TypeName(@name), @toks):
    args = Empty
    if parseArgs(toks) is _Parsed(@args, @toks):
      :::
    return _Parsed(CtorCall(name, args), toks)
  else:
    return NoParse

parseArgs(toks) -> :
  if toks is:
    Cons(OpenParen, Cons(CloseParen, @toks)):
      return _Parsed(Empty, toks)
    Cons(OpenParen, @toks):
      # We'll be evaluating the rule: '(' name (',' name)* ')'
      # As such, we first pick the first name, and then parse
      # comma-name as many times as we can.
      names = Empty
      if toks is:
        Cons(Identifier(name), @toks):
          names = Cons(name, Empty)
        *:
          return NoParse
      while toks is:
        Cons(CloseParen, @toks):
          names = reverse(names) # Cons pushes to back-to-front, we want front-to-back
          return _Parsed(names, toks)
        Cons(Comma, Cons(Identifier(name), @toks)):
          names = Cons(name, names)
        *:
          return NoParse
    *:
      return NoParse

main(args) -> :
  Stdout.print(parseFile(readTokens(Lexer.create(Stdin))))
  return 0
