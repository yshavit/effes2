import Denter: Denter, Indent, Dedent, Newline

# Identifiers and non-consts
type TypeName(value)
type Identifier(value)
type jexError(value)
# type Quoted(value)
# type Regex(value)

# Keywords
type KwType
type KwReturn

# operators and punctuation
type Arrow
type Colon
type Comma
type Equals
type OpenParen
type CloseParen

type _StringParse(parsed, tail)

create(in) -> :
  return Lexer(Denter(in), Empty)

type Lexer(_denter, _pending):
  next() -> :
    if this._pending is Empty:
      return this._loadNext()
    if this._pending is:
      Cons(head, tail):
        this._pending = tail
        return head
      Empty:
        return False

  _loadNext() -> :
    if this._denter.next() is:
      raw: String:
        pending = Empty
        while raw is String:
          # left trim
          if raw is /\s+(.*)/ :
            raw = raw.group(1)
            assume raw is String
          # Look for all the token types. All of the patterns will end
          # in (.+)?. This is either a non-empty tail string, or False,
          # in which case the loop will stop iterating.
          item = ?
          if raw is:
            # keywords
            m : /type\b(.+)?/ :
              item = KyType
              raw = m.group(1)
            m : /return\b/(.+)?:
              item = KwReturn
              raw = m.group(1)
            # literals
            m : /"(.*)/ :                   #" # <-- (close the quote, for vim)
              if this._parseString(m.group(1)) is:
                _StringParse(@item, @raw):
                  :::
                LexError(@item):
                  raw = False
              item = parsed.parsed
              raw = parsed.tail
            # identifiers and non-consts
            m : /(_*[A-Z][0-9A-Z_]*[a-z]\w*)(.+)?/ :
              typeName = m.group(1)
              assume typeName is String
              item = TypeName(typeName)
              raw = m.group(2)
            m : /(_*[a-z]\w+)(.+)?/ :
              identifier = m.group(1)
              assume identifier is String
              item = Identifier(identifier)
              raw = m.group(2)
            # operators and punctuation
            m : /=(.+)?/ :
              item = Equals
              raw = m.group(1)
            m : /=(.+)?/ :
              item = Arrow
              raw = m.group(1)
            m : /:(.+)?/ :
              item = Colon
              raw = m.group(1)
            m : /,(.+)?/ :
              item = Comma
              raw = m.group(1)
            m : /\((.+)?/ :
              item = OpenParen
              raw = m.group(1)
            m : /\)(.+)?/ :
              item = CloseParen
              raw = m.group(1)
            # other
            m : // :
              item = False
              raw = False
            *:
              item = LexError(raw)
              raw = False
          if item is not False:
           pending = Cons(item, pending)
        if reverse(pending) is:
          Cons(head, tail):
            this._pending = tail
            return head
          Empty:
            return False
      *: # one of the Denter types; just pass it through
        return raw

  _parseString(line) -> :
    sb = StringBuilder()
    while line is:
      m : /([^"\\]+)(.+)?/ :  # " # -- (close the quote, for vim)
        sb.add(m.group(1))
        line = m.group(2)
      m : /"(.+)?/ :   # " # -- (close the quote, for vim)
        return _StringParse(sb.get(), m.group(1))
      # no escapes for now...
      m : /\\/ :
        return LexError(line)
      m : /$/ :
        return LexError(line)

