import ConsList: Cons, Empty, reverse

type Indent
type Dedent
type Newline

type Denter(_in, _indents, _pending, _needTrailingNewline):
  next() -> : # NOTE: no type checking for now, just marks that there's a rv
    if this._pending is Empty:
      this._loadNext()
      if this._pending is Empty:
        return False
    if this._pending is:
      Cons(head, tail):
        this._pending = tail
        return head
      Empty:
        return False

  _loadNext():
    # This is a while-is loop. The evaluation/assignment is done at the start of each iteration.
    # Each of the matchers must end in "continue", "break" or "return"
    while line = _in.readLine() is:
      match : /^(\s*)(\S.*)$/ :
        m1 = match.group(1)
        m2 = match.group(2)
        assume m1 is String
        assume m2 is String
        indentCount = m1.length()
        # find and pop any dedents before the indent, adding Dedents as you go
        # We would eventually want to combine these two into an &&
        if this._indents is Cons(head: head >= indentCount, *):
          if this._needTrailingNewline:
            this._pending = Cons(Newline, this._pending)
        while this._indents is Cons(head: head > indentCount, tail):
          this._indents = tail
          this._pending = Cons(Dedent, this._pending)
        # Add an indent if needed
        if this._indents is Cons(head: head < indentCount, *):
          this._indents = Cons(indentCount, this._indents)
          this._pending = Cons(Indent, this._pending)
        # Finally, append the rest of the string, and reverse this._pending.
        # This is because Cons lists work as stacks, whereas we want a queue.
        # NOTE: I think this is actually incorrect, though I haven't come up with an example yet.
        # But I think we need to create a ConsQueue, using the two-conslist approach.
        this._pending = Cons(m2.length, this._pending)
        this._pending = reverse(this._pending)
        this._needTrailingNewline = True
        return # or break
      False:
        # no more lines; insert dedents as needed
        while this._indents is Cons(head: head > 0, tail):
          this._indents = tail
          this._pending = Cons(Dedent, this._pending)
        if this._needTrailingNewline:
          this._needTrailingNewline = False
          this._pending = Cons(Newline, this._pending)
        return
      *: continue # blank line

create(in) -> :
  return Denter(Cons(0, Empty), Empty, False)

main(args) -> :
  denter = create(Stdio.in)
  while denter.next() is:
    False:
      break
    e:
      Stdio.print(e)
      Stdio.print("\n")
      continue
  return 0
