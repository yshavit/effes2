efct 0
TYPE 0 Cons head tail
TYPE 0 Empty

FUNC : headIf 1 1 0 0
# returns the list's head, or False if it's Empty
pvar 0
typp :Cons
gofi 5    # jump to return False
pfld :Cons head
rtrn
pop       # return False
bool False
rtrn

FUNC : toString 1 1 0 1
# vars:
# 0: incoming list
# 1: stringbuilder
sbld
svar 1
pvar 1
str  "["
call_StringBuilder:add
pvar 0
type :Cons
goif 9            # jump to loop body
goto 24           # jump to loop end
pvar 1
pvar 0
pfld :Cons head
call_StringBuilder:add
pvar 0
pfld :Cons tail
svar 0
pvar 0            # if type($0) == cons, append ", "
type :Cons
goif 20           # jump to append ", "
goto 24           # exit loop
pvar 1
str  ", "
call_StringBuilder:add
goto 9            # top of loop
pvar 1
str  "]"
call_StringBuilder:add
pvar 1            # return sb.toString
call_native:toString
rtrn

FUNC : reverse 1 1 0 1
# reverses the given list, which is either a Cons or Empty
# $res = Empty
# while type($0) == Cons
#   $head = $0.head
#   $res = Cons(head, $res)
# return $res
#
# vars:
# 0: incoming list, which we'll also use as the list we pull from
# 1: $res
call :Empty Empty # $res = Empty
svar 1
labl @loop_top
pvar 0            # while type $0 == Cons
type :Cons
goif @loop_body
goto @loop_end
labl @loop_body
pvar 0            # (loop body) $res = Cons($0.head, $res)
pfld :Cons head
pvar 1
call :Cons Cons
svar 1
pvar 0            # $0 = $.tail
pfld :Cons tail
svar 0
goto @loop_top
labl @loop_end
pvar 1
rtrn

FUNC : main 1 1 0 1
# arg: list
call ConsList:Empty Empty
svar 1
call_String:sin      # read lines, put them into the list
typp False
goif 9               # exit the loop
pvar 1
call ConsList:Cons Cons
svar 1
goto 2               # top of the loop
pop                  # pop the "False" from String:sin
pvar 1
call ConsList: toString # call_native:toString
call_String:sout
str  "\n"
call_String:sout
pvar 1
call ConsList: reverse
call ConsList: toString # call_native:toString
call_String:sout
str  "\n"
call_String:sout
int  0
rtrn
