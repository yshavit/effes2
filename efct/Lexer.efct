efct 0

TYPE 0 TypeName value
TYPE 0 Identifier value
TYPE 0 LexError value
TYPE 0 KwType
TYPE 0 Arrow
TYPE 0 Colon
TYPE 0 Comma
TYPE 0 OpenParen
TYPE 0 CloseParen

TYPE 0 Lexer _denter _pending

FUNC : create 0 1 0
call Denter: create       # [Denter]
call ConsList:Empty Empty # [Denter, Empty]
call :Lexer Lexer         # [Lexer]
rtrn

FUNC Lexer next 0 1 0
pvar 0                    # [this]
pfld :Lexer _pending      # [this._pending]
type ConsList:Empty       # [bool]
gofi @after_check_empty   # []
pvar 0                    # [this]
call :Lexer _loadNext     # [result]
rtrn
labl @after_check_empty
pvar 0                    # [this]
pfld :Lexer _pending      # [this._pending]
typp ConsList:Cons        # [this._pending, bool]
gofi @post_is_cons        # [this._pending]
# $1: this._pending as Cons
svar 1                    # []
pvar 0                    # [this]
pvar 1                    # [this, this._pending]
pfld ConsList:Cons tail   # [this, this._pending.tail]
sfld :Lexer _pending      # []
pvar 1                    # [this._pending]
pfld ConsList:Cons head   # [this._pending.head]
rtrn
labl @post_is_cons
bool False
rtrn

FUNC Lexer _loadNext 0 1 0
# $1: raw
pvar 0                          # [this]
pfld :Lexer _denter             # [this._denter]
call Denter:Denter next         # [raw]
svar 1                          # []
pvar 1                          # [raw]
typp String                     # [raw, bool]
gofi @not_string                # [raw]
# if raw is String: ...
# Note that in the following cases, we can assume "raw" is a String
# $2: pending
pop
call ConsList:Empty Empty       # [Empty]
svar 2                          # []
labl @while_raw_is_string
pvar 1                          # [raw]
typf String                     # [(raw), bool]
gofi @line_loop_done            # []
str  "\\s+(.*)"                 # [raw, pattern]
call_String:regex               # [match?]
typf Match                      # [(match), bool]
gofi @no_leading_spaces         # []
int  1                          # [match, 1]
call_Match:igroup               # [group1]
svar 1                          # []
labl @no_leading_spaces
# "if raw is: ..." until @end_if_raw_is
# $3: item, $4: tmp
# 
# case "type"
pvar 1                          # [raw]
str "type\\s+(.+)?"             # [raw, pattern]
call_String:regex               # [match?]
typf Match                      # [(match), bool]
gofi @try_type_name             # []
call :KwType KwType             # [match, tok]
svar 3                          # [match]
int  1                          # [match, 1]
call_Match:igroup               # [nextraw]
svar 1                          # []
goto @end_if_raw_is
# case TypeName
labl @try_type_name
pvar 1                          # [raw]
str "(_*[A-Z][0-9A-Z_]*[a-z]\\w*)(.+)?" # [raw, pattern]
call_String:regex               # [match?]
typf Match                      # [(match), bool]
gofi @try_identifier            # []
svar 4                          # []
pvar 4                          # [match]
int  1                          # [match, 1]
call_Match:igroup               # [group1]
call :TypeName TypeName         # [typeName]
svar 3                          # []
pvar 4                          # [match]
int  2                          # [match, 2]
call_Match:igroup               # [nextRaw]
svar 1                          # []
goto @end_if_raw_is
# case Identifier
labl @try_identifier
pvar 1                          # [raw]
str "(_*[a-z]\\w+)(.+)?"        # [raw, pattern]
call_String:regex               # [match?]
typf Match                      # [(match), bool]
gofi @try_arrow                 # []
svar 4                          # []
pvar 4                          # [match]
int  1                          # [match, 1]
call_Match:igroup               # [group1]
call :Identifier Identifier     # [identifier]
svar 3                          # []
pvar 4                          # [match]
int  2                          # [match, 2]
call_Match:igroup               # [nextRaw]
svar 1                          # []
goto @end_if_raw_is
# case "arrow"
labl @try_arrow
pvar 1                          # [raw]
str "->(.+)?"                   # [raw, pattern]
call_String:regex               # [match?]
typf Match                      # [(match), bool]
gofi @try_colon                 # []
call :Arrow Arrow               # [match, tok]
svar 3                          # [match]
int  1                          # [match, 1]
call_Match:igroup               # [nextraw]
svar 1                          # []
goto @end_if_raw_is
# case "arrow"
labl @try_colon
pvar 1                          # [raw]
str ":(.+)?"                    # [raw, pattern]
call_String:regex               # [match?]
typf Match                      # [(match), bool]
gofi @try_comma                 # []
call :Colon Colon               # [match, tok]
svar 3                          # [match]
int  1                          # [match, 1]
call_Match:igroup               # [nextraw]
svar 1                          # []
goto @end_if_raw_is
# case "comma"
labl @try_comma
pvar 1                          # [raw]
str ",(.+)?"                    # [raw, pattern]
call_String:regex               # [match?]
typf Match                      # [(match), bool]
gofi @try_open_paren            # []
call :Comma Comma               # [match, tok]
svar 3                          # [match]
int  1                          # [match, 1]
call_Match:igroup               # [nextraw]
svar 1                          # []
goto @end_if_raw_is
# case "open paren"
labl @try_open_paren
pvar 1                          # [raw]
str "\\((.+)?"                  # [raw, pattern]
call_String:regex               # [match?]
typf Match                      # [(match), bool]
gofi @try_close_paren           # []
call :OpenParen OpenParen       # [match, tok]
svar 3                          # [match]
int  1                          # [match, 1]
call_Match:igroup               # [nextraw]
svar 1                          # []
goto @end_if_raw_is
# case "close_paren"
labl @try_close_paren
pvar 1                          # [raw]
str "\\((.+)?"                  # [raw, pattern]
call_String:regex               # [match?]
typf Match                      # [(match), bool]
gofi @try_end_of_string         # []
call :CloseParen CloseParen     # [match, tok]
svar 3                          # [match]
int  1                          # [match, 1]
call_Match:igroup               # [nextraw]
svar 1                          # []
goto @end_if_raw_is
# end of string
labl @try_end_of_string
pvar 1                          # [raw]
str ""                          # [raw, pattern]
call_String:regex               # [match?]
type Match                      # [bool]
gofi @if_string_else            # []
bool False                      # [match, tok]
svar 3                          # [match]
bool False                      # [nextraw]
svar 1                          # []
goto @end_if_raw_is
# if-String else
labl @if_string_else
pvar 1                          # [raw]
call :LexError LexError         # [LexError(raw)]
svar 3                          # []
bool False                      # [False]
svar 1                          # []
#
labl @end_if_raw_is
# if item is not False....
pvar 3                          # [item]
type False                      # [bool]
goif @item_not_false
pvar 3                          # [item]
pvar 2                          # [item, pending]
call ConsList:Cons Cons         # [Cons(item, pending)]
svar 2                          # []
labl @item_not_false
goto @while_raw_is_string       # top of the loop
labl @line_loop_done
pvar 2                          # [pending]
call ConsList: reverse          # [pendingReverse]
typf ConsList:Cons              # [(pendingReverse), bool]
gofi @reverse_is_empty
svar 4                          # []
pvar 0                          # [this]
pvar 4                          # [this, reversePending]
pfld ConsList:Cons tail         # [this, reversePending.tail]
sfld :Lexer _pending            # []
pvar 4                          # [reversePending]
pfld ConsList:Cons head         # [reversePending.head]
rtrn
labl @reverse_is_empty
bool False
rtrn
# if raw is *: return raw
labl @not_string                # [raw]
rtrn

FUNC : main 1 1 0
call : create                   # [Lexer]
svar 0                          # []
labl @loop_top
pvar 0                          # [lexer]
call :Lexer next                # [next]
svar 1                          # []
pvar 1                          # [next]
type False                      # [bool]
goif @loop_end                  # []
pvar 1                          # [next]
call_native:toString            # [str]
call_String:sout                # []
str  "\n"                       # ["\n"]
call_String:sout                # []
goto @loop_top
labl @loop_end
int  0
rtrn
