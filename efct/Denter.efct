efct 0

# Denter class and supporting types. From stdin, returns a stream of indents, dedents and strings.
# Each call to Denter.next returns one of Indent, Dedent, String or False (representing EOF).
# The Denter's state is:
#  - indents: a ConsList[Integer] of indentations. Every time you indent,
TYPE 0 Indent
TYPE 0 Dedent
TYPE 0 Denter _indents _pending

FUNC : create 0 1 0
int  0                      # [0]
call ConsList:Empty Empty   # [0, Empty]
call ConsList:Cons Cons     # [Cons(0,Empty)]
call ConsList:Empty Empty   # [Cons(0, Empty), Empty]
call :Denter Denter         # [Denter]
rtrn

FUNC Denter next 0 1 0
# $0: this
# $1: this._pending
# $2: result
pvar 0                               # [this]
pfld :Denter _pending                # [this._pending]
svar 1                               # []
pvar 1                               # [this._pending]
type ConsList:Empty                  # [bool]
gofi @if_not_empty
pvar 0                               # [this]
call :Denter _loadNext               # []
pvar 0                               # [this]
pfld :Denter _pending                # [this._pending]
typp ConsList:Empty                  # [this._pending, bool]
gofi @found_more_data                # [this._pending]
pop                                  # []
bool False                           # [False]
rtrn
labl @found_more_data                # [this._pending]
svar 1                               # []
labl @if_not_empty
pvar 1                               # [this._pending] ## $2 = _pending.head
pfld ConsList:Cons head              # [this._pending.head]
svar 2                               # []
pvar 0                               # [this] ## this._pending = this._pending.tail
pvar 1                               # [this, this._pending]
pfld ConsList:Cons tail              # [this, this._pending.tail]
sfld :Denter _pending                # []
pvar 2                               # [result]
rtrn

FUNC Denter _loadNext 0 0 0
# $0: this
# $1: the input string, and then the regex match
# $2: the input's indendation
labl @top
call_String:sin                      # [input?]
typp False                           # [input?, bool]
gofi @have_data                      # [input?]
# while (this._indents.head > 0):
#  pop this._indents
#  push a dedent
pop                                  # []
pvar 0                               # [this]
pfld :Denter _indents                # [this._indents]
pfld ConsList:Cons head              # [topIndent]
int  0                               # [topIndent, 0]
call_Integer:gt                      # [cmpBool]
gofi @eof_dedents_end                # []
pvar 0                               # [this]
pvar 0                               # [this, this]
pfld :Denter _indents                # [this, this._indents]
pfld ConsList:Cons tail              # [this, this._indents.tail]
sfld :Denter _indents                # []
pvar 0                               # [this]
call :Dedent Dedent                  # [this, Dedent]
pvar 0                               # [this, Dedent, this]
pfld :Denter _pending                # [this, Dedent, this._pending]
call ConsList:Cons Cons              # [this, Cons(Dedent, this._pending)]
sfld :Denter _pending                # []
labl @eof_dedents_end
rtrn
labl @have_data
svar 1                               # []
pvar 1                               # [input]
str  "^(\\s*)(\\S.*)$"               # [input, pattern]
call_String:regex                    # [matcher?]
svar 1                               # []
pvar 1                               # [matcher?]
typp False                           # [matcher?, bool]
gofi @matched                        # [matcher?]
goto @top                            ## means the string was all whitespace; try to find another
labl @matched                        ## We have our input string. Now find its indendtation in absolute chars
int  1                               # [matcher, 1]
call_Match:igroup                    # [indentStr?]
typp False                           # [indentStr?, bool]
gofi @have_indents                   # [indentStr?]
pop                                  # []
rtrn                                 ## Wouldn't expect this to actually happen
labl @have_indents
call_String:len                      # [indentNum]
svar 2                               # []
# find any dedents:
# while (this._indents.head > indentNum):
#   pop this._indents
#   push Dedent to this._pending
labl @dedents_loop_top               # []
pvar 0                               # [this]
pfld :Denter _indents                # [this._indents] ## We're going to cheat a bit and assume it's a Cons
pfld ConsList:Cons head              # [topIndent]
pvar 2                               # [topIndent, indentNum]
call_Integer:gt                      # [cmpBool]
gofi @dedents_loop_end               # []
pvar 0                               # [this] ## this._indents = this._indents.tail
pvar 0                               # [this, this]
pfld :Denter _indents                # [this, this._indents]
pfld ConsList:Cons tail              # [this, tailIndents]
sfld :Denter _indents                # []
pvar 0                               # [this] ## this._pending = Cons(Dedent, this._pending)
call :Dedent Dedent                  # [this, Dedent]
pvar 0                               # [this, Dedent, this]
pfld :Denter _pending                # [this, Dedent, _pending)
call ConsList:Cons Cons              # [this, ConsList(Dedent,_pending)]
sfld :Denter _pending                # []
goto @dedents_loop_top               # []
labl @dedents_loop_end
# if (this._indents.head < indentNum):
#  push indentNum to this._indents
#  push Indent to this._pending
pvar 0                               # [this]
pfld :Denter _indents                # [this._indents] ## We're going to cheat a bit and assume it's a Cons
pfld ConsList:Cons head              # [topIndent]
pvar 2                               # [topIndent, indentNum]
call_Integer:lt                      # [cmpBool]
gofi @done_with_indents              # []
pvar 0                               # [this] ## this._indents = Cons(indentNum, this._indents)
pvar 2                               # [this, indentNum]
pvar 0                               # [this, indentNum, this]
pfld :Denter _indents                # [this, indentNum, this._indents]
call ConsList:Cons Cons              # [this, Cons(indentNum, this._indents)]
sfld :Denter _indents                # []
pvar 0                               # [this] ## this._pending = Cons(Indent, this._pending)
call :Indent Indent                  # [this, Indent]
pvar 0                               # [this, Indent, this]
pfld :Denter _pending                # [this, Indent, _pending)
call ConsList:Cons Cons              # [this, Cons(Indent,_pending)]
sfld :Denter _pending                # []
# Finally, append the rest of the string, and reverse this._pending
labl @done_with_indents
pvar 0                               # [this]
pvar 1                               # [this, matcher]
int  2                               # [this, matcher, 2]
call_Match:igroup                    # [this, payload]
pvar 0                               # [this, payload, this]
pfld :Denter _pending                # [this, payload, this._pending]
call ConsList:Cons Cons              # [this, Cons(payload, this._pending)]
call ConsList: reverse               # [this, reversedPending]
sfld :Denter _pending                # []
rtrn

FUNC : main 1 1 0
call : create
svar 1
labl @loop_top
pvar 1
call :Denter next
typp False
goif @exit
call_native:toString
call_String:sout
str  "\n"
call_String:sout
goto @loop_top
labl @exit
pop  # the Denter instance
int  0
rtrn
