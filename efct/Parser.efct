efct 0

TYPE 0 EfFile types
TYPE 0 EfType name args
TYPE 0 EfArgs names
TYPE 0 NoParse
TYPE 0 _Parsed element remainingTokens

FUNC : readTokens 1 1 0
# $0: lexer
# $1: toks
call ConsList:Empty Empty       # [Empty]
svar 1                          # []
labl @loop_top                  # []
pvar 0                          # [lexer]
call Lexer:Lexer next           # [next]
typp False                      # [next, isFalse]
gofi @not_false                 # [next]
pop                             # []
pvar 1                          # [toks]
call ConsList: reverse          # [toks']
rtrn
labl @not_false                 # [next]
pvar 1                          # [next, toks]
call ConsList:Cons Cons         # [Cons(~)]
svar 1                          # []
goto @loop_top                  # []

FUNC : parseFile 1 1 0
# $0: toks
# $1: types
# $2: tmp
#
# while parseType(toks)...
call ConsList:Empty Empty       # [Empty]
svar 1                          # []
labl @loop_top                  # []
pvar 0                          # [toks]
call : parseType                # [parseRv]
typf :_Parsed                   # [parseRv?, isParsed]
gofi @loop_end                  # [parseRv]
Pfld :_Parsed element           # [parseRv, parseRv.element]
svar 2                          # [parseRv]
pfld :_Parsed remainingTokens   # [parseRv.remainingTokens]
svar 0                          # []
pvar 2                          # [parseRv.element]
pvar 1                          # [parseRv.element, types]
call ConsList:Cons Cons         # [Cons(element, types)]
svar 1                          # []
goto @loop_top                  # []
labl @loop_end                  # [parseRV]
#pop                             # []
pvar 0                          # [toks]
type ConsList:Empty             # [isEmpty]
gofi @no_parse                  # []
pvar 1                          # [types]
call :EfFile EfFile             # [EfFile(types)]
rtrn
labl @no_parse                  # []
call :NoParse NoParse           # [NoParse]
rtrn

FUNC : parseType 1 1 0 
# $0: toks
# $1: name
# $2: args
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_parse                  # [toks]
Pfld ConsList:Cons head         # [toks, toks.head]
type Lexer:KwType               # [toks, toks.head, headHeadIsKwType]
gofi @no_parse2                 # [toks, toks.head]
pfld ConsList:Cons tail         # [toks, toks.head.tail]
typf ConsList:Cons              # [toks, toks.head?, headIsCons]
gofi @no_parse1                 # [toks, toks.head]
Pfld ConsList:Cons head         # [toks, toks.head, toks.head.head]
typf Lexer:TypeName             # [toks, toks.head.tail?, isId]
gofi @no_parse1                 # [toks, toks.head.tail]
pfld Lexer:TypeName value       # [toks, idValue]
svar 1                          # [toks]
pfld ConsList:Cons tail         # [toks.tail]
svar 0                          # []
call ConsList:Empty Empty       # [Empty]
svar 2                          # []
pvar 0                          # [toks]
call : parseArgs                # [parseRv]
typf :_Parsed                   # [parseRv?, isParsed]
gofi @bind_end                  # [parseRv]
Pfld :_Parsed element           # [parseRv, element]
svar 2                          # [parseRv]
pfld :_Parsed remainingTokens   # [tail]
svar 0                          # []
labl @bind_end                  # []
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_parse                  # [toks]
Pfld ConsList:Cons head         # [toks, toks.head]
type Denter:Newline             # [toks, headIsNewline]
gofi @no_parse1                 # [toks]
pfld ConsList:Cons tail         # [toks.tail]
svar 0                          # []
pvar 1                          # [name]
pvar 2                          # [name, args]
call :EfType EfType             # [EfType(~)]
pvar 0                          # [EfType(~), toks]
call :_Parsed _Parsed           # [Parsed(~)]
rtrn
labl @no_parse2                 # [x, x]
pop                             # [x]
labl @no_parse1                 # [x]
pop                             # []
labl @no_parse                  # []
call :NoParse NoParse           # [NoParse]
rtrn
# $1: types
call ConsList:Empty Empty       # [Empty]
svar 1                          # []
labl @loop_top                  # []
pvar 0                          # [toks]

FUNC : parseArgs 1 1 0
# $0: toks
# $1: names
# $2: name
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, toksIsCons]
gofi @no_parse-a                # [toks]
# Combine the first two "Cons" matchers, up until the cons.tail
# For the first one, we'll check if it's CloseParen. Otherwise we'll
# just bind it to $toks
#
# first Cons matcher
Pfld ConsList:Cons head         # [toks, toks.h]
type Lexer:OpenParen            # [toks, toks.h.isOpenParen]
gofi @no_parse-a-1              # [toks]
Pfld ConsList:Cons tail         # [toks, toks.t]
typf ConsList:Cons              # [toks, toks.t?, toks.t.isCons]
gofi @no_parse-a-1              # [toks, toks.t]
Pfld ConsList:Cons head         # [toks, toks.t, toks.t.h]
type Lexer:CloseParen           # [toks, toks.t, toks.t.h.isCloseParen]
gofi @if_cons_b                 # [toks, toks.t]
pfld ConsList:Cons tail         # [toks, toks.t.t]
svar 0                          # [toks]
# first Cons matched
pop                             # []
call ConsList:Empty Empty       # [Empty]
call :EfArgs EfArgs             # [EfArgs(Empty)]
pvar 0                          # [EfArgs(Empty), toks]
call :_Parsed _Parsed           # [_Parsed(~)]
rtrn                            # []
# second Cons matcher
labl @if_cons_b                 # [toks, toks.t]
svar 0                          # [toks]
pop                             # []
# second Cons matched
call ConsList:Empty Empty       # [Empty]
svar 1                          # []
# "if toks is Cons(Identifier(...))
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, toksIsCons]
gofi @no_parse_b                # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
typf Lexer:Identifier           # [toks, toks.h?, toks.h.isIdentifier]
gofi @no_parse_b-1              # [toks, toks.h]
pfld Lexer:Identifier value     # [toks, toks.h.val]
svar 2                          # [toks]
pfld ConsList:Cons tail         # [toks.t]
svar 0                          # []
pvar 2                          # [name]
call ConsList:Empty Empty       # [name, Empty]
call ConsList:Cons Cons         # [Cons(name,Empty)]
svar 1                          # []
goto @after_if_b                # []
labl @no_parse_b-1              # [toks]
pop                             # []
labl @no_parse_b                # []
call :NoParse NoParse           # [NoParse]
rtrn                            # []
labl @after_if_b                # []
# "while toks is"...
labl @loop_top                  # []
pvar 0                          # [toks]
# while loop's first two Cons share the Cons check
typf ConsList:Cons              # [toks?, toksIsCons]
gofi @loop_return_noparse       # [toks]
# first check
Pfld ConsList:Cons head         # [toks, toks.h]
type Lexer:CloseParen           # [toks, toks.h.isCloseParen]
gofi @loop-second-cons          # [toks]
pfld ConsList:Cons tail         # [toks.t]
# first check matched
svar 0                          # []
pvar 1                          # [names]
svar 1                          # []
pvar 1                          # [names]
call ConsList: reverse          # [names]
call :EfArgs EfArgs             # [EfArgs(names)]
pvar 0                          # [EfArgs(names), toks]
call :_Parsed _Parsed           # [_Parsed(~)]
rtrn
# second check
labl @loop-second-cons          # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
type Lexer:Comma                # [toks, toks.h.isComma]
gofi @loop_return_noparse-1     # [toks]
Pfld ConsList:Cons tail         # [toks, toks.t]
typf ConsList:Cons              # [toks, toks.t?, toks.t.isCons]
gofi @loop_return_noparse-1     # [toks, toks.t]
pfld ConsList:Cons head         # [toks, toks.t.h]
typf Lexer:Identifier           # [toks, toks.t.h?, toks.t.h.isIdentifier]
gofi @loop_return_noparse-1     # [toks, toks.t.h]
pfld Lexer:Identifier value     # [toks, toks.t.h.value]
svar 2                          # [toks]
pfld ConsList:Cons tail         # [toks.t]
pfld ConsList:Cons tail         # [toks.t.t]
svar 0                          # []
# second check matched
pvar 2                          # [name]
pvar 1                          # [name, names]
call ConsList:Cons Cons         # [Cons(~)]
svar 1                          # []
goto @loop_top                  # []
# while loop's NoParse
labl @loop_return_noparse-1     # [toks]
pop                             # p[
labl @loop_return_noparse       # []
call :NoParse NoParse           # [NoParse]
rtrn
# top-level NoParse
labl @no_parse-a-1              # [toks]
pop                             # []
labl @no_parse-a                # []
call :NoParse NoParse           # [NoParse]
rtrn                            # []

FUNC : main 1 1 0
call_Stream:stdin               # [stdin]
call Lexer: create              # [lexer]
call : readTokens               # [toks]
call : parseFile                # [parse]
call_native:toString            # [parseString]
call_String:sout                # []
str  "\n"                       # ["\n"]
call_String:sout                # []
int  0                          # [0]
rtrn
