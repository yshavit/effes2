input: |
  :::
localVars:
  a:
    reg: 7
    type: null
expect: ''
---
name: assign a var, others in reg
input: |
  abc = 123
localVars:
  a:
    reg: 7
    type: null
expect: |
  int 123
  svar 8
---
name: assign a var, nothing in reg
input: |
  abc = 123
expect: |
  int 123
  svar 0
---
input: |
  abc = 123
localVars:
  abc:
    reg: 3
expect: |
  int 123
  svar 3
---
name: 'assign multiline'
input: |
  abc = if a is:
    One: "one"
    Two: "two"
localVars:
  a:
    reg: 2
---
name: static method, no args, with rv
input: 'foo()'
types:
  '':
    methods:
      foo:
        declaredArgs: 0
        hasRv: true
expect: |
  call : foo
  pop
---
name: instance method, with args, no arv
input: 'foo(a)'
instanceContextType: SomeType
types:
  SomeType:
    methods:
      foo:
        declaredArgs: 1
        hasRv: false
localVars:
  a:
    reg: 3
expect: |
  pvar 3
  pvar 0
  call :SomeType foo
---
name: while colon
input: |
  while condition():
    doSomething()
types:
  '':
    methods:
      condition:
        declaredArgs: 0
        hasRv: true
      doSomething:
        declaredArgs: 0
        hasRv: false
expect: |
  labl whileLoopTop
  call : condition
  gofi whileLoopEnd
  call : doSomething
  goto whileLoopTop
  labl whileLoopEnd
---
name: while is
input: |
  while thing is:
    String:
      doStringThing()
    Int:
      doIntThing()
    Foo:
      break
    Bar:
      return
    Baz:
      continue
localVars:
  thing:
    reg: 1
types:
  '':
    methods:
      doStringThing:
        declaredArgs: 0
        hasRv: false
      doIntThing:
        declaredArgs: 0
        hasRv: false
expect: |
  labl whileLoopTop     # []
  pvar 1                # [thing]
  typp String           # [thing, thingIsString]
  goif match_1_String   # [thing]
  goto matcher          # [thing]
  labl match_1_String   # [thing]   (if is String)
  pop                   # []
  call : doStringThing  # []
  goto whileLoopTop     # []
  labl matcher          # [thing]
  typp Int              # [thing, isInt]
  goif match_1_Int      # [thing]
  goto matcher:1        # [thing]
  labl match_1_Int      # [thing]  (if is Int)
  pop                   # []
  call : doIntThing     # []
  goto whileLoopTop     # []
  labl matcher:1        # [thing]
  typp Foo              # [thing, isFoo]
  goif match_1_Foo      # [thing]
  goto matcher:2        # [thing]
  labl match_1_Foo      # [thing]  (if is Foo)
  pop                   # []
  goto whileLoopEnd     # []
  labl matcher:2        # [thing]
  typp Bar              # [thing, isBar]
  goif match_1_Bar      # [thing]
  goto matcher:3        # [thing]
  labl match_1_Bar      # [thing]  (if is Bar)
  pop                   # []
  rtrn                  # []
  labl matcher:3        # [thing]
  typp Baz              # [thing, isBaz]
  goif match_1_Baz      # [thing]
  goto whileLoopEnd     # [thing]  (final case failure falls through to end)
  labl match_1_Baz      # [thing]  (if is Baz)
  pop                   # []
  goto whileLoopTop     # []
  labl whileLoopEnd     # []
---
name: complex flow
input: |
  while outerCondition() is:
    Go:
      while innerCondition():
        if innerMostCondition() is:
          ContinueType:
            continue
          ReturnType:
            return
          BreakType:
            break
          *:
            trySomething()
    Stay:
      trySomething()
types:
  '':
    methods:
      outerCondition: { declaredArgs: 0, hasRv: true }
      innerCondition: { declaredArgs: 0, hasRv: true }
      innerMostCondition: { declaredArgs: 0, hasRv: true }
      trySomething: { declaredArgs: 0, hasRv: true }
expect: |
  labl whileLoopTop             # []
  call : outerCondition         # [oCond]
  typp Go                       # [oCond, isGo]
  goif match_1_Go               # [oCond]
  goto matcher                  # [oCond]
  labl match_1_Go               # [oCond]
  pop                           # []
  labl whileLoopTop:1           # []
  call : innerCondition         # [iCond]
  gofi whileLoopEnd:1           # []
  call : innerMostCondition     # [imCond]
  typp ContinueType             # [imCond, isCont]
  goif match_1_ContinueType     # [imCond]
  goto matcher:1                # [imCond]
  labl match_1_ContinueType     # [imCond]
  pop                           # []
  goto whileLoopTop:1           # []
  labl matcher:1                # [imCond]
  typp ReturnType               # [imCond, isRet]
  goif match_1_ReturnType       # [imCond]
  goto matcher:2                # [imCond]
  labl match_1_ReturnType       # [imCond]
  pop                           # []
  rtrn                          # []
  labl matcher:2                # [imCond]
  typp BreakType                # [imCond, isBreak]
  goif match_1_BreakType        # [imCond]
  goto matcher:3                # [imCond]
  labl match_1_BreakType        # [imCond]
  pop                           # []
  goto whileLoopEnd:1           # []
  labl matcher:3                # [imCond]
  pop                           # []
  call : trySomething           # [rv]
  pop                           # []
  goto matchersEnd              # []
  labl matchersEnd              # []
  goto whileLoopTop:1           # []  (go back to inner loop)
  labl whileLoopEnd:1           # []  (inner loop end)
  goto whileLoopTop             # []  (back to outer loop)
  labl matcher                  # [oCond]  (way back from the outer condition!)
  typp Stay                     # [oCond, isStay]
  goif match_1_Stay             # [oCond]
  goto whileLoopEnd             # [] (exit outer loop)
  labl match_1_Stay             # [oCond]
  pop                           # []
  call : trySomething           # [rv]
  pop                           # []
  goto whileLoopTop             # [] (back to outer loop)
  labl whileLoopEnd             # [] (end outer loop)
---
input: 'abc ::: One(val)'
localVars:
  abc: { reg: 1 }
types:
  One:
    fields: [value]
expect: |
  pvar 1                # [abc]
  typp One              # [abc, isOne]
  goif match_1_One      # [abc]
  pop                   # []
  goto statMatcherEnd   # []
  labl match_1_One      # [abc]  (if is One)
  Pfld One value        # [abc, abc.val]
  Svar 2                # [abc, abc.val]  {$2=val}
  pop                   # [abc]
  pop                   # []
  labl statMatcherEnd   # []
---
input: |
  for a in foo():
    workWith(a)
types:
  '':
    methods:
      workWith:
        declaredArgs: 1
        hasRv: false
      foo:
        declaredArgs: 0
        hasRv: true
expect: |
  call : foo          # [fooRv]
  copy                # [fooRv, fooRv]
  call_Array:len      # [fooRv, fooRv.len]
  svar 1              # [fooRv]                 {$1=len}
  int 0               # [fooRv, 0]
  svar 2              # [fooRv]                 {$1=len, $2=idx}
  labl loopTop        # [fooRv]
  pvar 1              # [fooRv, len]
  pvar 2              # [fooRv, len, idx]
  call_Integer:ge     # [fooRv, lenGtIdx]
  gofi loopDone       # [fooRv]
  copy                # [fooRv, fooRv]
  pvar 2              # [fooRv, fooRv, idx]
  call_Array:get      # [fooRv, elem]
  svar 0              # [fooRv]                 {$1=len, $2=idx, $0=elem}
  pvar 0              # [fooRv, elem]           (start of loop body)
  call : workWith     # [fooRv]
  pvar 2              # [fooRv, idx]
  int 1               # [fooRv, idx, 1]
  call_Integer:add    # [fooRv, idx+1]
  svar 2              # [fooRv]                 {$1=len, $2=idx+1, $0=elem}
  goto loopTop        # [fooRv]
  labl loopDone       # [fooRv]
  pop                 # []


---
input: abc = ?
expect: ''  # just establishes the var
---
name: 'if-else'
input: |
  if a:
    doA()
  else:
    doB()
localVars:
  a: { reg: 1 }
types:
  '':
    methods:
      doA: { declaredArgs: 0, hasRv: false }
      doB: { declaredArgs: 0, hasRv: false }
---
name: 'if-else if'
input: |
  if a:
    doA()
  else if b:
    doB()
localVars:
  a: { reg: 1 }
  b: { reg: 1 }
types:
  '':
    methods:
      doA: { declaredArgs: 0, hasRv: false }
      doB: { declaredArgs: 0, hasRv: false }
---
name: 'if-else if-else chain'
input: |
  if a:
    doA()
  else if b:
    doB()
  else if c:
    doC()
  else:
    doD() # hehehe "doodie"
localVars:
  a: { reg: 1 }
  b: { reg: 1 }
  c: { reg: 1 }
types:
  '':
    methods:
      doA: { declaredArgs: 0, hasRv: false }
      doB: { declaredArgs: 0, hasRv: false }
      doC: { declaredArgs: 0, hasRv: false }
      doD: { declaredArgs: 0, hasRv: false }
---
name: assign to field with unqualified name
input: value = "one"
instanceContextType: SomeType
types:
  SomeType:
    fields: [value]
---
input: this.value = "one"
instanceContextType: SomeType
localVars:
  value:
    reg: 666
types:
  SomeType:
    fields: [value]
---
name: return with value
input: |
  while a:
    return "single value"
localVars:
  a:
    reg: 1
---
name: return with value multiline
input: |
  while a:
    return if b is:
      One: "one"
      Two: "two"
localVars:
  a:
    reg: 2
  b:
    reg: 3
---
name: TODO StatementCompilerTest should have a switch for whether rv is expected
