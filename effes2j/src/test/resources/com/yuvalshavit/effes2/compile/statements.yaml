input: |
  :::
localVars:
  a:
    reg: 7
    type: null
expect: ''
---
name: assign a var, others in reg
input: |
  abc = 123
localVars:
  a:
    reg: 7
    type: null
expect: |
  int 123
  svar 8
---
name: assign a var, nothing in reg
input: |
  abc = 123
expect: |
  int 123
  svar 0
---
input: |
  abc = 123
localVars:
  abc:
    reg: 3
expect: |
  int 123
  svar 3
---
name: 'assign multiline'
types:
  One: {fields: []}
  Two: {fields: []}
input: |
  abc = if a is:
    One: "one"
    Two: "two"
localVars:
  a:
    reg: 2
expect: |
  pvar 2                    # [a]
  Svar 4                    # [a]   $4=a
  typp :One                 # [a, aIsOne]
  gofi match_fail_pop_1     # [a]
  pop                       # []
  goto exprMultiMatched     # []
  labl match_fail_pop_1     # [a]
  pop                       # []
  pvar 4                    # [a]
  goto exprMultiTry         # [a]
  labl exprMultiMatched     # []
  str one                   # ["one"]
  svar 3                    # []    $3="one"
  goto exprMultiDone        # []
  labl exprMultiTry         # [a]
  typp :Two                 # [a, aIsTwo]
  gofi match_fail_pop_1:1   # [a]
  pop                       # []
  goto exprMultiMatched:1   # []
  labl match_fail_pop_1:1   # [a]
  pop                       # []
  goto exprMultiTry:1       # []
  labl exprMultiMatched:1   # []
  str two                   # ["two"]
  svar 3                    # []    $3="two"
  goto exprMultiDone        # []
  labl exprMultiTry:1       # []
  fail "no alternatives matched"
  labl exprMultiDone        # []
---
name: static method, no args, with rv
input: 'foo()'
staticMethods:
  foo:
    declaredArgs: 0
    hasRv: true
expect: |
  call : foo
  pop
---
name: instance method, one arg, no arv
input: 'foo(a)'
instanceContextType: SomeType
types:
  SomeType:
    methods:
      foo:
        declaredArgs: 1
        hasRv: false
localVars:
  a:
    reg: 3
expect: |
  pvar 0
  pvar 3
  call :SomeType foo
---
name: static method, three args, no arv
input: 'foo(1, 2, 3)'
staticMethods:
  foo:
    declaredArgs: 3
    hasRv: false
expect: |
  int 3
  int 2
  int 1
  call : foo
---
name: while colon
input: |
  while condition():
    doSomething()
staticMethods:
  condition:
    declaredArgs: 0
    hasRv: true
  doSomething:
    declaredArgs: 0
    hasRv: false
expect: |
  labl whileLoopTop
  call : condition
  gofi whileLoopEnd
  call : doSomething
  goto whileLoopTop
  labl whileLoopEnd
---
name: while is
input: |
  while thing is:
    String:
      doStringThing()
    Int:
      doIntThing()
    Foo:
      break
    Bar:
      return
    Baz:
      continue
localVars:
  thing:
    reg: 1
types:
  String: {fields: []}
  Int: {fields: []}
  Foo: {fields: []}
  Bar: {fields: []}
  Baz: {fields: []}
staticMethods:
  doStringThing:
    declaredArgs: 0
    hasRv: false
  doIntThing:
    declaredArgs: 0
    hasRv: false
expect: |
  labl whileLoopTop                 # []
  pvar 1                            # [thing]
  Svar 2                            # [thing]   $2=thing
  typp :String                      # [thing, thingIsString]
  gofi match_fail_pop_1             # [thing]
  pop                               # []
  goto whileMultiMatched            # []
  labl match_fail_pop_1             # [thing]
  pop                               # []
  pvar 2                            # [thing]
  goto whileMultiTry                # [thing]
  labl whileMultiMatched            # []
  call : doStringThing              # []
  goto whileLoopTop                 # []
  labl whileMultiTry                # [thing]
  Svar 2                            # [thing]   $2=thing
  typp :Int                         # [thing, thingIsInt]
  gofi match_fail_pop_1:1           # (etc etc..)
  pop
  goto whileMultiMatched:1
  labl match_fail_pop_1:1
  pop
  pvar 2
  goto whileMultiTry:1
  labl whileMultiMatched:1
  call : doIntThing
  goto whileLoopTop
  labl whileMultiTry:1
  Svar 2
  typp :Foo
  gofi match_fail_pop_1:2
  pop
  goto whileMultiMatched:2
  labl match_fail_pop_1:2
  pop
  pvar 2
  goto whileMultiTry:2
  labl whileMultiMatched:2
  goto whileLoopEnd
  labl whileMultiTry:2
  Svar 2
  typp :Bar
  gofi match_fail_pop_1:3
  pop
  goto whileMultiMatched:3
  labl match_fail_pop_1:3
  pop
  pvar 2
  goto whileMultiTry:3
  labl whileMultiMatched:3
  rtrn
  labl whileMultiTry:3
  typp :Baz
  gofi match_fail_pop_1:4
  pop
  goto whileMultiMatched:4
  labl match_fail_pop_1:4
  pop
  goto whileLoopEnd
  labl whileMultiMatched:4
  goto whileLoopTop
  labl whileLoopEnd
---
name: complex flow
input: |
  while outerCondition() is:
    Go:
      while innerCondition():
        if innerMostCondition() is:
          ContinueType:
            continue
          ReturnType:
            return
          BreakType:
            break
          a:
            trySomething(a)
    Stay(a):
      trySomething(a)
staticMethods:
  outerCondition: { declaredArgs: 0, hasRv: true }
  innerCondition: { declaredArgs: 0, hasRv: true }
  innerMostCondition: { declaredArgs: 0, hasRv: true }
  trySomething: { declaredArgs: 1, hasRv: true }
types:
  Go: {fields: []}
  Stay: {fields: [val]}
  ContinueType: {fields: []}
  ReturnType: {fields: []}
  BreakType: {fields: []}
expect: |
  labl whileLoopTop                     # []
  call : outerCondition                 # [cond]
  Svar 0                                # [cond]    $0=cond
  typp :Go                              # [cond, condIsGo]
  gofi match_fail_pop_1                 # [cond]
  pop                                   # []
  goto whileMultiMatched                # []
  labl match_fail_pop_1                 # [cond]
  pop                                   # []
  pvar 0                                # [cond]
  goto whileMultiTry                    # [cond]
  labl whileMultiMatched                # []
  labl whileLoopTop:1                   # []                  (innermost loop)
  call : innerCondition                 # [innerCond]
  gofi whileLoopEnd:1                   # []
  call : innerMostCondition             # [innestCond]
  Svar 1                                # [innestCond]   $1=innestCond
  typp :ContinueType                    # [innestCond, innestCondIsContinue]
  gofi match_fail_pop_1:1               # [innestCond]
  pop                                   # []
  goto whileMultiMatched:1              # []
  labl match_fail_pop_1:1               # [innestCond]
  pop                                   # []
  pvar 1                                # [innestCond]
  goto whileMultiTry:1                  # [innestCond]
  labl whileMultiMatched:1              # []                  (if ContinueType)
  goto whileLoopTop:1                   # []                  (to innermost loop head, above)
  labl whileMultiTry:1                  # [innestCond]
  Svar 1                                # [innestCond]  $1=innestCOnd
  typp :ReturnType                      # [innestCond, innestCondIsReturn]
  gofi match_fail_pop_1:2               # [innestCond]
  pop                                   # []
  goto whileMultiMatched:2              # []
  labl match_fail_pop_1:2               # [innestCond]
  pop                                   # []
  pvar 1                                # [innestCond]
  goto whileMultiTry:2                  # [innestCond]
  labl whileMultiMatched:2              # []                  (if ReturnType)
  rtrn                                  # <rtrn>
  labl whileMultiTry:2                  # [innestCond]
  Svar 1                                # [innestCond]    $1=innestCond
  typp :BreakType                       # [innestCond, innestIsBreak]
  gofi match_fail_pop_1:3               # [innestCond]
  pop                                   # []
  goto whileMultiMatched:3              # []
  labl match_fail_pop_1:3               # [innestCond]
  pop                                   # []
  pvar 1                                # [innestCond]
  goto whileMultiTry:3                  # [innestCond]
  labl whileMultiMatched:3              # []                  (if BreakType)
  goto whileLoopEnd:1                   # []
  labl whileMultiTry:3                  # [innestCond]
  Svar 1                                # [innestCond]    $1=innestCond
  pop                                   # []
  goto whileMultiMatched:4              # []
  labl whileMultiMatched:4              # []
  pvar 1                                # [innestCond]
  call : trySomething                   # [rv]
  pop                                   # []
  goto matchersEnd                      # []
  labl matchersEnd                      # []
  goto whileLoopTop:1                   # []
  labl whileLoopEnd:1                   # []
  goto whileLoopTop                     # []          (top of inner loop, though we can't actually reach this op)
  labl whileMultiTry                    # [cond]      (all the way from the outer loop)
  typp :Stay                            # [cond, condIsStay]
  gofi match_fail_pop_1:4               # [cond]
  Pfld :Stay val                        # [cond, cond.val]
  Svar 0                                # [cond, cond.val]    $0=cond.val
  pop                                   # [cond]
  pop                                   # []
  goto whileMultiMatched:5              # []
  labl match_fail_pop_1:4               # [cond]
  pop                                   # []
  goto whileLoopEnd                     # []          (top loop end)
  labl whileMultiMatched:5              # []
  pvar 0                                # [cond.val]
  call : trySomething                   # [rv]
  pop                                   # []
  goto whileLoopTop                     # []
  labl whileLoopEnd                     # []
---
input: 'abc ::: One(val)'
localVars:
  abc: { reg: 1 }
types:
  One:
    fields: [value]
expect: |
  pvar 1                  # [abc]
  typp :One               # [abc, abcIsOne]
  gofi match_fail_pop_1   # [abc]
  Pfld :One value         # [abc, abc.value]
  Svar 2                  # [abc, abc.value]    $2=abc.value
  pop                     # []
  pop                     # []
  goto statMatcherEnd     # []
  labl match_fail_pop_1   # [abd]
  pop                     # []
  goto statMatcherEnd     # []
  labl statMatcherEnd     # []
---
input: |
  for a in foo():
    workWith(a)
staticMethods:
  workWith:
    declaredArgs: 1
    hasRv: false
  foo:
    declaredArgs: 0
    hasRv: true
expect: |
  call : foo              # [foos]
  copy                    # [foos, foos]
  call_Array:len          # [foos, foos.len]
  svar 1                  # [foos]            $1=foos.len
  int 0                   # [foos, 0]
  svar 2                  # [foos]            $2=idx
  labl loopTop            # [foos]
  pvar 1                  # [foos, foos.len]
  pvar 2                  # [foos, foos.len, idx]
  call_Integer:ge         # [foos, idx>=foos.len]
  gofi loopDone           # [foos]
  copy                    # [foos, foos]
  pvar 2                  # [foos, foos, idx]
  call_Array:get          # [foos, foos@idx]
  svar 0                  # [foos]            $0=foos@idx
  pvar 0                  # [foos, foos@idx]
  call : workWith         # [foos]
  pvar 2                  # [foos, idx]
  int 1                   # [foos, idx, 1]
  call_Integer:add        # [foos, idx+1]
  svar 2                  # [foos]
  goto loopTop            # [foos]
  labl loopDone           # [foos]
  pop                     # []
---
input: abc = ?
expect: ''  # just establishes the var
---
name: 'if-else'
input: |
  if a:
    doA()
  else:
    doB()
localVars:
  a: { reg: 1 }
staticMethods:
  doA: { declaredArgs: 0, hasRv: false }
  doB: { declaredArgs: 0, hasRv: false }
expect: |
  pvar 1                  # [a]
  gofi ifNot              # []
  call : doA              # []
  goto ifChainEnd         # []
  labl ifNot              # []
  call : doB              # []
  labl ifChainEnd         # []
---
name: 'if-else if'
input: |
  if a:
    doA()
  else if b:
    doB()
localVars:
  a: { reg: 1 }
  b: { reg: 2 }
staticMethods:
    doA: { declaredArgs: 0, hasRv: false }
    doB: { declaredArgs: 0, hasRv: false }
expect: |
  pvar 1            # [a]
  gofi ifNot        # []
  call : doA        # []
  goto ifChainEnd   # []
  labl ifNot        # []
  pvar 2            # [b]
  gofi elseIfNot    # []
  call : doB        # []
  labl elseIfNot    # []
  labl ifChainEnd   # []
---
name: 'if-else if-else chain'
input: |
  if a:
    doA()
  else if b:
    doB()
  else if c:
    doC()
  else:
    doD() # hehehe "doodie"
localVars:
  a: { reg: 1 }
  b: { reg: 2 }
  c: { reg: 3 }
staticMethods:
  doA: { declaredArgs: 0, hasRv: false }
  doB: { declaredArgs: 0, hasRv: false }
  doC: { declaredArgs: 0, hasRv: false }
  doD: { declaredArgs: 0, hasRv: false }
expect: |
  pvar 1            # [a]
  gofi ifNot        # []
  call : doA        # []
  goto ifChainEnd   # []
  labl ifNot        # []
  pvar 2            # [b]
  gofi elseIfNot    # []
  call : doB        # []
  goto ifChainEnd   # []
  labl elseIfNot    # []
  pvar 3            # [c]
  gofi elseIfNot:1  # []
  call : doC        # []
  goto ifChainEnd   # []
  labl elseIfNot:1  # []
  call : doD        # []
  labl ifChainEnd   # []
---
name: assign to field with unqualified name
input: value = "one"
instanceContextType: SomeType
types:
  SomeType:
    fields: [value]
expect: |
  str one
  pvar 0
  sfld :SomeType value
---
input: this.value = "one"
instanceContextType: SomeType
localVars:
  value:
    reg: 666
types:
  SomeType:
    fields: [value]
expect: |
  str one
  pvar 0
  sfld :SomeType value
---
name: return with value
input: |
  while a:
    return "single value"
localVars:
  a:
    reg: 1
expect: |
  labl whileLoopTop  # []
  pvar 1             # [a]
  gofi whileLoopEnd  # []
  str "single value" # [str]
  rtrn               # returned
  labl whileLoopEnd  # []
---
name: return with value multiline
input: |
  while a:
    return if b is:
      One: "one"
      Two: "two"
types:
  One: {fields: []}
  Two: {fields: []}
localVars:
  a:
    reg: 2
  b:
    reg: 3
expect: |
  labl whileLoopTop
  pvar 2
  gofi whileLoopEnd
  pvar 3
  Svar 5
  typp :One
  gofi match_fail_pop_1
  pop
  goto exprMultiMatched
  labl match_fail_pop_1
  pop
  pvar 5
  goto exprMultiTry
  labl exprMultiMatched
  str one
  svar 4
  goto exprMultiDone
  labl exprMultiTry
  typp :Two
  gofi match_fail_pop_1:1
  pop
  goto exprMultiMatched:1
  labl match_fail_pop_1:1
  pop
  goto exprMultiTry:1
  labl exprMultiMatched:1
  str two
  svar 4
  goto exprMultiDone
  labl exprMultiTry:1
  fail "no alternatives matched"
  labl exprMultiDone
  pvar 4
  rtrn
  labl whileLoopEnd
---
name: if-is brings type info
input: |
  if a is Dog:
    a.bark()
localVars:
  a:
    reg: 0
    type: null
types:
  Dog:
    fields: []
    methods:
      bark:
        declaredArgs: 0
        hasRv: false
expect: |
  pvar 0
  typp :Dog
  gofi match_fail_pop_1
  pop
  goto isA_true
  labl match_fail_pop_1
  pop
  goto isA_false
  labl isA_true
  bool True
  goto isA_done
  labl isA_false
  bool False
  labl isA_done
  gofi ifNot
  pvar 0
  call :Dog bark
  labl ifNot
  labl ifChainEnd
---
name: if-matchers brings type info
input: |
  if a is:
    Dog:
      a.bark()
localVars:
  a:
    reg: 1
    type: null
types:
  Dog:
    fields: []
    methods:
      bark:
        declaredArgs: 0
        hasRv: false
expect: |
  pvar 1
  typp :Dog
  gofi match_fail_pop_1
  pop
  goto whileMultiMatched
  labl match_fail_pop_1
  pop
  goto matchersEnd
  labl whileMultiMatched
  pvar 1
  call :Dog bark
  goto matchersEnd
  labl matchersEnd
---
name: single matcher with simple binding
input: |
  if foo(var) is:
    Success(@var):
      return var
localVars:
  var:
    reg: 0
    type: null
types:
  Success:
    fields: [value]
staticMethods:
  foo:
    declaredArgs: 1
    hasRv: true
expect: |
  pvar 0                  # [var]
  call : foo              # [fooRv]
  typp :Success           # [fooRv, fooRvIsSuccess]
  gofi match_fail_pop_1   # [fooRv]
  Pfld :Success value     # [fooRv, fooRv.value]
  Svar 1                  # [fooRv, fooRv.value]    $1=fooRv.value
  pop                     # [fooRv]
  pop                     # []
  pvar 1                  # [fooRv.value]
  svar 0                  # []                      $0=fooRv.value
  goto whileMultiMatched  # []
  labl match_fail_pop_1   # [fooRv]
  pop                     # []
  goto matchersEnd        # []
  labl whileMultiMatched  # []
  pvar 0                  # [value]
  rtrn                    # <return>
  labl matchersEnd        # []
---
name: single matcher with binding and guard
input: |
  if foo(var) is:
    Success(@var if guard(var)):
      return var
localVars:
  var:
    reg: 0
    type: null
types:
  Success:
    fields: [value]
staticMethods:
  foo:
    declaredArgs: 1
    hasRv: true
  guard:
    declaredArgs: 1
    hasRv: true
expect: |
  pvar 0                  # [value]
  call : foo              # [fooRv]
  typp :Success           # [fooRv, fooRvIsSuccess]
  gofi match_fail_pop_1   # [fooRv]
  Pfld :Success value     # [fooRv, fooRv.value]
  Svar 1                  # [fooRv, fooRv.value]      $1=fooRv.value
  pop                     # [fooRv]
  pvar 1                  # [fooRv, fooRv.value]
  call : guard            # [fooRv, guardRv]
  gofi match_fail_pop_1   # [fooRv]
  pop                     # []
  pvar 1                  # [fooRv.value]
  svar 0                  # []                        $0=value
  goto whileMultiMatched  # []
  labl match_fail_pop_1   # [fooRv]
  pop                     # []
  goto matchersEnd        # []
  labl whileMultiMatched  # []
  pvar 0                  # [fooRv.value]
  rtrn                    # <return>
  labl matchersEnd        # []
