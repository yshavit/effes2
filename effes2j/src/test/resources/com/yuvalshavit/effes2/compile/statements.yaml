input: |
  :::
localVars:
  a:
    reg: 7
    type: null
expect: ''
---
name: assign a var, others in reg
input: |
  abc = 123
localVars:
  a:
    reg: 7
    type: null
expect: |
  int 123
  svar 8
---
name: assign a var, nothing in reg
input: |
  abc = 123
expect: |
  int 123
  svar 0
---
input: |
  abc = 123
localVars:
  abc:
    reg: 3
expect: |
  int 123
  svar 3
---
name: static method, no args, with rv
input: 'foo()'
types:
  '':
    methods:
      foo:
        declaredArgs: 0
        hasRv: true
expect: |
  call : foo
  pop
---
name: instance method, with args, no arv
input: 'foo(a)'
instanceContextType: SomeType
types:
  SomeType:
    methods:
      foo:
        declaredArgs: 1
        hasRv: false
localVars:
  a:
    reg: 3
expect: |
  pvar 3
  pvar 0
  call :SomeType foo
---
name: while colon
input: |
  while condition():
    doSomething()
types:
  '':
    methods:
      condition:
        declaredArgs: 0
        hasRv: true
      doSomething:
        declaredArgs: 0
        hasRv: false
expect: |
  labl whileLoopTop
  call : condition
  gofi whileLoopEnd
  call : doSomething
  goto whileLoopTop
  labl whileLoopEnd
---
name: while is
input: |
  while thing is:
    String:
      doStringThing()
    Int:
      doIntThing()
    Foo:
      break
    Bar:
      return
    Baz:
      continue
localVars:
  thing:
    reg: 1
types:
  '':
    methods:
      doStringThing:
        declaredArgs: 0
        hasRv: false
      doIntThing:
        declaredArgs: 0
        hasRv: false
expect: |
  labl whileLoopTop     # []
  pvar 1                # [thing]
  typp String           # [thing, thingIsString]
  goif match_1_String   # [thing]
  goto matcher          # [thing]
  labl match_1_String   # [thing]   (if is String)
  pop                   # []
  call : doStringThing  # []
  goto whileLoopTop     # []
  labl matcher          # [thing]
  typp Int              # [thing, isInt]
  goif match_1_Int      # [thing]
  goto matcher:1        # [thing]
  labl match_1_Int      # [thing]  (if is Int)
  pop                   # []
  call : doIntThing     # []
  goto whileLoopTop     # []
  labl matcher:1        # [thing]
  typp Foo              # [thing, isFoo]
  goif match_1_Foo      # [thing]
  goto matcher:2        # [thing]
  labl match_1_Foo      # [thing]  (if is Foo)
  pop                   # []
  goto whileLoopEnd     # []
  labl matcher:2        # [thing]
  typp Bar              # [thing, isBar]
  goif match_1_Bar      # [thing]
  goto matcher:3        # [thing]
  labl match_1_Bar      # [thing]  (if is Bar)
  pop                   # []
  rtrn                  # []
  labl matcher:3        # [thing]
  typp Baz              # [thing, isBaz]
  goif match_1_Baz      # [thing]
  goto whileLoopEnd     # [thing]  (final case failure falls through to end)
  labl match_1_Baz      # [thing]  (if is Baz)
  pop                   # []
  goto whileLoopTop     # []
  labl whileLoopEnd     # []
---
name: complex flow
input: |
  while outerCondition() is:
    Go:
      while innerCondition():
        if innerMostCondition() is:
          ContinueType:
            continue
          ReturnType:
            return
          BreakType:
            break
          *:
            trySomething()
    Stay:
      trySomething()
types:
  '':
    methods:
      outerCondition: { declaredArgs: 0, hasRv: true }
      innerCondition: { declaredArgs: 0, hasRv: true }
      innerMostCondition: { declaredArgs: 0, hasRv: true }
      trySomething: { declaredArgs: 0, hasRv: true }
expect: |
  labl whileLoopTop             # []
  call : outerCondition         # [oCond]
  typp Go                       # [oCond, isGo]
  goif match_1_Go               # [oCond]
  goto matcher                  # [oCond]
  labl match_1_Go               # [oCond]
  pop                           # []
  labl whileLoopTop:1           # []
  call : innerCondition         # [iCond]
  gofi whileLoopEnd:1           # []
  call : innerMostCondition     # [imCond]
  typp ContinueType             # [imCond, isCont]
  goif match_1_ContinueType     # [imCond]
  goto matcher:1                # [imCond]
  labl match_1_ContinueType     # [imCond]
  pop                           # []
  goto whileLoopTop:1           # []
  labl matcher:1                # [imCond]
  typp ReturnType               # [imCond, isRet]
  goif match_1_ReturnType       # [imCond]
  goto matcher:2                # [imCond]
  labl match_1_ReturnType       # [imCond]
  pop                           # []
  rtrn                          # []
  labl matcher:2                # [imCond]
  typp BreakType                # [imCond, isBreak]
  goif match_1_BreakType        # [imCond]
  goto matcher:3                # [imCond]
  labl match_1_BreakType        # [imCond]
  pop                           # []
  goto whileLoopEnd:1           # []
  labl matcher:3                # [imCond]
  pop                           # []
  call : trySomething           # [rv]
  pop                           # []
  goto matchersEnd              # []
  labl matchersEnd              # []
  goto whileLoopTop:1           # []  (go back to inner loop)
  labl whileLoopEnd:1           # []  (inner loop end)
  goto whileLoopTop             # []  (back to outer loop)
  labl matcher                  # [oCond]  (way back from the outer condition!)
  typp Stay                     # [oCond, isStay]
  goif match_1_Stay             # [oCond]
  goto whileLoopEnd             # [] (exit outer loop)
  labl match_1_Stay             # [oCond]
  pop                           # []
  call : trySomething           # [rv]
  pop                           # []
  goto whileLoopTop             # [] (back to outer loop)
  labl whileLoopEnd             # [] (end outer loop)
