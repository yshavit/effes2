input: a
localVars:
  a:
    reg: 7
    type: null
expect: |
  pvar 7
---
input: a + b
localVars:
  a:
    reg: 7
  b:
    reg: 0
expect: |
  pvar 7
  pvar 0
  call_Integer:add
---
input: a * (b - c)
localVars:
  a:
    reg: 0
  b:
    reg: 1
  c:
    reg: 2
expect: |
  pvar 0
  pvar 1
  pvar 2
  call_Integer:sub
  call_Integer:mult
---
input: a < b
localVars:
  a:
    reg: 0
  b:
    reg: 1
expect: |
  pvar 0
  pvar 1
  call_Integer:lt
---
input: this
localVars:
  <this>:
    reg: 3
expect: |
  pvar 3
---
input: not foo
localVars:
  foo:
    reg: 0
expect: |
  pvar 0
  call_Boolean:negate
---
input: 1234
expect: |
  int 1234
---
input: '"hello"'
expect: |
  str hello
---
input: '"hello world"'
expect: |
  str "hello world"
---
input: '"Let''s build a â˜ƒ, man!"'
expect: |
  str "Let's build a \u2603, man!"
---
input: 'foo is One(bar)'
types:
  One:
    fields: [value]
localVars:
  foo:
    reg: 0
expect: |
  pvar 0            # [foo]
  typp One          # [foo, isOne]
  goif match_1_One  # [foo]
  pop               # []
  goto isA_false    # []
  labl match_1_One  # [foo]
  Pfld One value    # [foo, foo.value]
  Svar 1            # [foo, foo.value]  {$1=foo.value}
  pop               # [foo]
  pop               # []
  bool True         # [true]
  goto isA_done     # [true]
  labl isA_false    # []
  bool False        # [false]
  labl isA_done     # [trueOrFalse]
---
input: 'foo is One(@bar)'
types:
  One:
    fields: [value]
localVars:
  foo:
    reg: 0
  bar:
    reg: 1
expect: |
  pvar 0            # [foo]
  typp One          # [foo, isOne]
  goif match_1_One  # [foo]
  pop               # []
  goto isA_false    # []
  labl match_1_One  # [foo]
  Pfld One value    # [foo, foo.value]
  Svar 2            # [foo, foo.value]   {$2=foo.value}
  pop               # [foo]
  pvar 2            # [foo, foo.value]   {$2=foo.value}
  svar 1            # [foo]              {$1=foo.value, $2=foo.value}
  pop               # []
  bool True         # [true]
  goto isA_done     # [true]
  labl isA_false    # []
  bool False        # [false]
  labl isA_done     # [trueOrFalse]
---
input: 'foo is not One(bar)'
types:
  One:
    fields: [value]
localVars:
  foo:
    reg: 0
expect: |
  pvar 0            # [foo]
  typp One          # [foo, isOne]
  goif match_1_One  # [foo]
  pop               # []
  goto isA_false    # []
  labl match_1_One  # [foo]
  Pfld One value    # [foo, foo.value]
  Svar 1            # [foo, foo.value]  {$1=foo.value}
  pop               # [foo]
  pop               # []
  bool False        # [false]
  goto isA_done     # [false]
  labl isA_false    # []
  bool True         # [true]
  labl isA_done     # [trueOrFalse]
---
input: dog.eat(food)
types:
  Dog:
    methods:
      eat:
        declaredArgs: 1
        hasRv: true
localVars:
  dog:
    reg: 1
    type: Dog
  food:
    reg: 2
expect: |
  pvar 2
  pvar 1
  call :Dog eat
---
input: Nothing
types:
  Nothing: { fields: [] }
expect: |
  call :Nothing Nothing
---
input: Pair(a, b)
localVars:
  a:
    reg: 3
  b:
    reg: 4
types:
  Pair: { fields: [first, second] }
expect: |
  pvar 4
  pvar 3
  call :Pair Pair
