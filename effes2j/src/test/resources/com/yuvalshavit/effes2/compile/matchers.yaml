name: wild, keep unmatched
keepIfNotMatched: true
match: '*'
expect: |
  pop
  goto @MATCHED
---
name: wild, pop unmatched
keepIfNotMatched: false
match: '*'
expect: |
  pop
  goto @MATCHED
---
name: just name
keepIfNotMatched: true
match: 'abc'
expect: |
  Svar 0
  pop
  goto @MATCHED
---
name: guarded name, keep unmatched
keepIfNotMatched: true
match: abc :? abc == 1
expect: |
  Svar 0
  pvar 0
  int 1
  call_Integer:eq
  goif match_1_suchThat
  goto @UNMATCHED
  labl match_1_suchThat
  pop
  goto @MATCHED
---
name: guarded name, pop unmatched
keepIfNotMatched: false
match: abc :? abc == 1
expect: |
  Svar 0
  pvar 0
  int 1
  call_Integer:eq
  goif match_1_suchThat
  pop
  goto @UNMATCHED
  labl match_1_suchThat
  pop
  goto @MATCHED
---
name: singleton type pattern
keepIfNotMatched: false
match: Nothing
expect: |
  typp Nothing
  goif match_1_Nothing
  pop
  goto @UNMATCHED
  labl match_1_Nothing
  pop
  goto @MATCHED
---
name: regex type pattern, keep unmatched
keepIfNotMatched: true
match: '~/foo (\w+)/'
expect: |
  #                       # [val]
  typp String             # [val, isStr]
  goif match_1_String     # [val]
  goto @UNMATCHED         # [val]
  labl match_1_String     # [val]
  str "foo (\\w+)"        # [val, pattern]
  call_String:regex       # [val, matchOrFalse]
  type Match              # [val, isMatch]
  goif match_1_suchThat   # [val]
  goto @UNMATCHED         # [val]
  labl match_1_suchThat   # [val]
  pop                     # []
  goto @MATCHED           # []
---
name: regex type pattern, pop unmatched
keepIfNotMatched: false
match: '~/foo (\w+)/'
expect: |
  #                       # [val]
  typp String             # [val, isStr]
  goif match_1_String     # [val]
  pop                     # [], due to keepIfNotMatched = false
  goto @UNMATCHED         # []
  labl match_1_String     # [val]
  str "foo (\\w+)"        # [val, pattern]
  call_String:regex       # [val, matchOrFalse]
  type Match              # [val, isMatch]
  goif match_1_suchThat   # [val]
  pop                     # [], due to keepIfNotMatched = false
  goto @UNMATCHED         # []
  labl match_1_suchThat   # [val]
  pop                     # []
  goto @MATCHED           # []
---
# Note that this is pretty much the same as the regex test,
# but with the regex string being literal
name: string literal pattern
keepIfNotMatched: false
match: '"foo\\bar"'   #literal "foo\bar". One level of quoted needed for Effes; yaml doesn't seem to need it.
expect: |
  typp String
  goif match_1_String
  pop
  goto @UNMATCHED
  labl match_1_String
  str "\\Qfoo\\bar\\E"
  call_String:regex
  type Match
  goif match_1_suchThat
  pop
  goto @UNMATCHED
  labl match_1_suchThat
  pop
  goto @MATCHED
---
name: complex
keepIfNotMatched: true
match: Triple(*, abc :? abc > 1, Pair("lit string", patty ~/\\d+/)) :? abc < to_int(patty))
expect: |
  #                         # [val]
  typp Triple               # [val, isTriple]
  goif match_1_Triple       # [val]
  goto @UNMATCHED           # [val]
  labl match_1_Triple       # [val]
  Svar 0                    # [val] -- {$0=val} ERROR! SHOULD BE FETCHING THE FIELD!
  ...
