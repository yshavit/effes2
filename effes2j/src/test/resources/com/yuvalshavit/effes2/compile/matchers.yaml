name: wild, keep unmatched
options: { keepIfNotMatched: true }
input: '*'
expect: |
  pop
  goto @MATCHED
---
name: wild, pop unmatched
options: { keepIfNotMatched: false }
input: '*'
expect: |
  pop
  goto @MATCHED
---
name: just name
options: { keepIfNotMatched: true }
input: 'abc'
expect: |
  Svar 0
  pop
  goto @MATCHED
---
name: guarded name, keep unmatched
options: { keepIfNotMatched: true }
input: abc :? abc == 1
expect: |
  Svar 0
  pvar 0
  int 1
  call_Integer:eq
  goif match_1_suchThat
  goto @UNMATCHED
  labl match_1_suchThat
  pop
  goto @MATCHED
---
name: guarded name, pop unmatched
options: { keepIfNotMatched: false }
input: abc :? abc == 1
expect: |
  Svar 0
  pvar 0
  int 1
  call_Integer:eq
  goif match_1_suchThat
  pop
  goto @UNMATCHED
  labl match_1_suchThat
  pop
  goto @MATCHED
---
name: guarded name to parent scope
options: { keepIfNotMatched: true }
localVars:
  oneVar: {reg: 0}
  abc: {reg: 1}
  twoVar: {reg: 2}
input: '@abc :? abc == 1'
expect: |
  Svar 3
  pvar 3
  int 1
  call_Integer:eq
  goif match_1_suchThat
  goto @UNMATCHED
  labl match_1_suchThat
  pvar 3
  svar 1
  pop
  goto @MATCHED
---
name: singleton type pattern
options: { keepIfNotMatched: false }
input: Nothing
expect: |
  typp Nothing
  goif match_1_Nothing
  pop
  goto @UNMATCHED
  labl match_1_Nothing
  pop
  goto @MATCHED
---
name: regex type pattern, keep unmatched
options: { keepIfNotMatched: true }
input: '~/foo (\w+)/'
expect: |
  #                       # [val]
  typp String             # [val, isStr]
  goif match_1_String     # [val]
  goto @UNMATCHED         # [val]
  labl match_1_String     # [val]
  str "foo (\\w+)"        # [val, pattern]
  call_String:regex       # [val, matchOrFalse]
  type Match              # [val, isMatch]
  goif match_1_suchThat   # [val]
  goto @UNMATCHED         # [val]
  labl match_1_suchThat   # [val]
  pop                     # []
  goto @MATCHED           # []
---
name: regex type pattern, pop unmatched
options: { keepIfNotMatched: false }
input: '~/foo (\w+)/'
expect: |
  #                       # [val]
  typp String             # [val, isStr]
  goif match_1_String     # [val]
  pop                     # [], due to keepIfNotMatched = false
  goto @UNMATCHED         # []
  labl match_1_String     # [val]
  str "foo (\\w+)"        # [val, pattern]
  call_String:regex       # [val, matchOrFalse]
  type Match              # [val, isMatch]
  goif match_1_suchThat   # [val]
  pop                     # [], due to keepIfNotMatched = false
  goto @UNMATCHED         # []
  labl match_1_suchThat   # [val]
  pop                     # []
  goto @MATCHED           # []
---
# Note that this is pretty much the same as the regex test,
# but with the regex string being literal
name: string literal pattern
options: { keepIfNotMatched: false }
input: '"foo\\bar"'   #literal "foo\bar". One level of quoted needed for Effes; yaml doesn't seem to need it.
expect: |
  typp String
  goif match_1_String
  pop
  goto @UNMATCHED
  labl match_1_String
  str "\\Qfoo\\bar\\E"
  call_String:regex
  type Match
  goif match_1_suchThat
  pop
  goto @UNMATCHED
  labl match_1_suchThat
  pop
  goto @MATCHED
---
name: complex
options: { keepIfNotMatched: true }
input: Triple(*, abc :? abc > 1, Pair("lit string", patty ~/\d+/))
types:
  Triple:
    fields: [t0, t1, t2]
  Pair:
    fields: [p0, p1]
expect: |
  #                         # [val]
  typp Triple               # [val, isTriple]
  goif match_1_Triple       # [val]
  goto @UNMATCHED           # [val]
  labl match_1_Triple       # [val]
  Pfld Triple t0            # [val, t0]
  pop                       # [val]
  Pfld Triple t1            # [val, t1]
  Svar 0                    # [val, t1]                   -- {$0=t1}
  pvar 0                    # [val, t1, t1]               -- {$0=t1}
  int 1                     # [val, t1, t1, 1]            -- {$0=t1}
  call_Integer:gt           # [val, t1, t1=1]             -- {$0=t1}
  goif match_2_suchThat     # [val, t1]                   -- {$0=t1}
  pop                       # [val]                       -- {$0=t1} TODO unset this?
  goto @UNMATCHED           # [val]                       -- {$0=t1}
  labl match_2_suchThat     # [val, t1]                   -- {$0=t1}
  pop                       # [val]                       -- {$0=t1}
  Pfld Triple t2            # [val, t2]                   -- {$0=t1}
  typp Pair                 # [val, t2, t2isPair]         -- {$0=t1}
  goif match_2_Pair         # [val, t2]                   -- {$0=t1}
  pop                       # [val]                       -- {$0=t1}
  goto @UNMATCHED           # [val]                       -- {$0=t1}
  labl match_2_Pair         # [val, t2]                   -- {$0=t1}
  Pfld Pair p0              # [val, t2, pair.p0]          -- {$0=t1}
  typp String               # [val, t2, p0, p0IsString]   -- {$0=t1}
  goif match_3_String       # [val, t2, p0]               -- {$0=t1}
  pop                       # [val, t2]                   -- {$0=t1}
  pop                       # [val]                       -- {$0=t1}
  goto @UNMATCHED           # [val]                       -- {$0=t1}
  labl match_3_String       # [val, t2, p0]               -- {$0=t1}
  str "\\Qlit string\\E"    # [val, t2, p0, litStr]       -- {$0=t1}
  call_String:regex         # [val, t2, p0, matchOrFalse] -- {$0=t1}
  type Match                # [val, t2, p0, isMatch]      -- {$0=t1}
  goif match_3_suchThat     # [val, t2, p0]               -- {$0=t1}
  pop                       # [val, t2]                   -- {$0=t1}
  pop                       # [val]                       -- {$0=t1}
  goto @UNMATCHED           # [val]                       -- {$0=t1}
  labl match_3_suchThat     # [val, t2, p0]               -- {$0=t1}
  pop                       # [val, t2]                   -- {$0=t1}
  Pfld Pair p1              # [val, t2, p1]               -- {$0=t1}
  Svar 1                    # [val, t2, p1]               -- {$0=t1, $1=p1}
  typp String               # [val, t2, p1, p1IsString]   -- {$0=t1, $1=p1}
  goif match_3_String:1     # [val, t2, p1]               -- {$0=t1, $1=p1}
  pop                       # [val, t2]                   -- {$0=t1, $1=p1}
  pop                       # [val]                       -- {$0=t1, $1=p1}
  goto @UNMATCHED           # [val]                       -- {$0=t1, $1=p1}
  labl match_3_String:1     # [val, t2, p1]               -- {$0=t1, $1=p1}
  str "\\d+"                # [val, t2, p1, digRegex]     -- {$0=t1, $1=p1}
  call_String:regex         # [val, t2, p1, matchOrFalse] -- {$0=t1, $1=p1}
  type Match                # [val, t2, p1, isMatch]      -- {$0=t1, $1=p1}
  goif match_3_suchThat:1   # [val, t2, p1]               -- {$0=t1, $1=p1}
  pop                       # [val, t2]                   -- {$0=t1, $1=p1}
  pop                       # [val]                       -- {$0=t1, $1=p1}
  goto @UNMATCHED           # [val]                       -- {$0=t1, $1=p1}
  labl match_3_suchThat:1   # [val, t2, p1]               -- {$0=t1, $1=p1}
  pop                       # [val, t2]                   -- {$0=t1, $1=p1}
  pop                       # [val]                       -- {$0=t1, $1=p1}
  pop                       # []                          -- {$0=t1, $1=p1}
  goto @MATCHED             # []                          -- {$0=t1, $1=p1}
