efct 0

TYPE 0 EfFile types methods
TYPE 0 EfType name args
TYPE 0 EfMethod name args hasRv statements

# statements
TYPE 0 EfStatAssign name expr

# expressions
TYPE 0 CtorCall typeName args

TYPE 0 NoParse
TYPE 0 _Parsed element remainingTokens

FUNC : readTokens 1 1 0
# $0: lexer
# $1: toks
call ConsList:Empty Empty       # [Empty]
svar 1                          # []
labl @loop_top                  # []
pvar 0                          # [lexer]
call Lexer:Lexer next           # [next]
typp False                      # [next, isFalse]
gofi @not_false                 # [next]
pop                             # []
pvar 1                          # [toks]
call ConsList: reverse          # [toks']
rtrn
labl @not_false                 # [next]
pvar 1                          # [next, toks]
call ConsList:Cons Cons         # [Cons(~)]
svar 1                          # []
goto @loop_top                  # []

FUNC : parseFile 1 1 0
# $0: toks
# $1: types
# $2: methods
# $3: tmp
call ConsList:Empty Empty       # [Empty]
svar 1                          # []
call ConsList:Empty Empty       # [Empty]
svar 2                          # []
labl @loop_top                  # []
pvar 0                          # [toks]
type ConsList:Empty             # [toksIsEmpty]
goif @loop_end                  # []
# if parseType(toks)...
pvar 0                          # [toks]
call : parseType                # [parseRv]
typf :_Parsed                   # [parseRv?, isParsed]
gofi @elif_parseMethod          # [parseRv]
Pfld :_Parsed element           # [parseRv, elem]
svar 3                          # [parseRv]
pfld :_Parsed remainingTokens   # [toks']
svar 0                          # []
pvar 3                          # [elem]
pvar 1                          # [elem, types]
call ConsList:Cons Cons         # [Cons(~)]
svar 1                          # []
goto @if_end                    # []
# elif parseMethod(toks)...
labl @elif_parseMethod          # []
pvar 0                          # [toks]
call : parseMethod              # [parseRv]
typf :_Parsed                   # [parseRv?, isParsed]
gofi @else                      # [parseRv]
Pfld :_Parsed element           # [parseRv, elem]
svar 3                          # [parseRv]
pfld :_Parsed remainingTokens   # [toks']
svar 0                          # []
pvar 3                          # [elem]
pvar 2                          # [elem, methods]
call ConsList:Cons Cons         # [Cons(~)]
svar 2                          # []
goto @if_end                    # []
# else
labl @else                      # []
call :NoParse NoParse           # [NoParse]
rtrn
labl @if_end                    # []
goto @loop_top                  # []
labl @loop_end                  # []
# loop end
pvar 1                          # [types]
call ConsList: reverse          # [types']
svar 1                          # []
pvar 2                          # [methods]
call ConsList: reverse          # [methods']
svar 2                          # []
pvar 1                          # [types]
pvar 2                          # [types, methods]
call :EfFile EfFile             # [EfFile(~)]
rtrn

FUNC : parseType 1 1 0 
# $0: toks
# $1: name
# $2: args
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_parse                  # [toks]
Pfld ConsList:Cons head         # [toks, toks.head]
type Lexer:KwType               # [toks, toks.head, headHeadIsKwType]
gofi @no_parse1                 # [toks, toks.head]
pfld ConsList:Cons tail         # [toks, toks.head.tail]
typf ConsList:Cons              # [toks, toks.head?, headIsCons]
gofi @no_parse1                 # [toks, toks.head]
Pfld ConsList:Cons head         # [toks, toks.head, toks.head.head]
typf Lexer:TypeName             # [toks, toks.head.tail?, isId]
gofi @no_parse1                 # [toks, toks.head.tail]
pfld Lexer:TypeName value       # [toks, idValue]
svar 1                          # [toks]
pfld ConsList:Cons tail         # [toks.tail]
svar 0                          # []
call ConsList:Empty Empty       # [Empty]
svar 2                          # []
pvar 0                          # [toks]
call : parseArgs                # [parseRv]
typf :_Parsed                   # [parseRv?, isParsed]
gofi @try_end                   # [parseRv]
Pfld :_Parsed element           # [parseRv, element]
svar 2                          # [parseRv]
pfld :_Parsed remainingTokens   # [tail]
svar 0                          # []
labl @try_end                   # []
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_parse                  # [toks]
Pfld ConsList:Cons head         # [toks, toks.head]
type Denter:Newline             # [toks, headIsNewline]
gofi @no_parse1                 # [toks]
pfld ConsList:Cons tail         # [toks.tail]
svar 0                          # []
pvar 1                          # [name]
pvar 2                          # [name, args]
call :EfType EfType             # [EfType(~)]
pvar 0                          # [EfType(~), toks]
call :_Parsed _Parsed           # [Parsed(~)]
rtrn
labl @no_parse2                 # [x, x]
pop                             # [x]
labl @no_parse1                 # [x]
pop                             # []
labl @no_parse                  # []
call :NoParse NoParse           # [NoParse]
rtrn
# $1: types
call ConsList:Empty Empty       # [Empty]
svar 1                          # []
labl @loop_top                  # []
pvar 0                          # [toks]

FUNC : parseMethod 1 1 0 
# $0: toks
# $1: name
# $2: args
# $3: hasRv
# $4: statements
# 
# find method name
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_parse                  # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
typf Lexer:Identifier           # [toks, toks.h?, isId]
gofi @no_parse_1                # [toks, toks.h]
pfld Lexer:Identifier value     # [toks, name]
svar 1                          # [toks]
pfld ConsList:Cons tail         # [toks.t]
svar 0                          # []
# find args
pvar 0                          # [toks]
call : parseArgs                # [args]
typf :_Parsed                   # [parsedArgs?, isParsed]
gofi @no_parse                  # [parsedArgs]
Pfld :_Parsed element           # [parsedArgs, args]
svar 2                          # [parsedArgs]
pfld :_Parsed remainingTokens   # [parsedArgs.tail]
svar 0                          # []
# hasRv ...
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_rv                     # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
type Lexer:Arrow                # [toks, toks.h.isArrow]
gofi @no_rv_1                   # [toks]
pfld ConsList:Cons tail         # [toks.t]
svar 0                          # []
bool True                       # [True]
goto @set_rv                    # [hasRv]
labl @no_rv_1                   # [x]
pop                             # []
labl @no_rv                     # []
bool False                      # [False]
labl @set_rv                    # [hasRv]
svar 3                          # []
# find colon
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_parse                  # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
type Lexer:Colon                # [toks, toks.h.isColon]
gofi @no_parse_1                # [toks]
pfld ConsList:Cons tail         # [toks.t]
svar 0                          # []
# parse block
pvar 0                          # [toks]
call : parseBlock               # [tryParseBlock]
typf :_Parsed                   # [tryParseBlock?, isParsed]
gofi @no_parse                  # [tryParseBlock]
Pfld :_Parsed element           # [tryParseBlock, tryParseBlock.elem]
svar 4                          # [tryParseBlock]
pfld :_Parsed remainingTokens   # [tryParseBlock.t]
svar 0                          # []
# return
pvar 1                          # [name]
pvar 2                          # [name, args]
pvar 3                          # [name, args, hasRv]
pvar 4                          # [name, args, hasRv, statements]
call :EfMethod EfMethod         # [EfMethod(~)]
pvar 0                          # [EfMethod(~), toks]
call :_Parsed _Parsed           # [_Parsed(~)]
rtrn
labl @no_parse_1                # [x]
pop                             # []
labl @no_parse                  # []
call :NoParse NoParse           # [NoParse]
rtrn

FUNC : parseBlock 1 1 0
# $0: toks
# $1: statements
# $2: tmp
#
# look for indent
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_parse                  # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
type Denter:Indent              # [toks, toks.h.isIndent]
gofi @no_parse_1                # [toks]
pfld ConsList:Cons tail         # [toks.t]
svar 0                          # []
# loop over toks
call ConsList:Empty Empty       # [Empty]
svar 1                          # []
labl @loop_top
pvar 0                          # [toks]
# if Cons(Dedent...
typp ConsList:Cons              # [toks, isCons]
gofi @loop_else                 # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
type Denter:Dedent              # [toks, toks.h.isDedent]
gofi @loop_else                 # [toks]
pfld ConsList:Cons tail         # [toks.t]
svar 0                          # []
pvar 1                          # [statements]
call ConsList: reverse          # [statements']
pvar 0                          # [statements', toks]
call :_Parsed _Parsed           # [_Parsed(~)]
rtrn
# else...
labl @loop_else                 # [toks]
call : parseStatement           # [stmtRv]
typf :_Parsed                   # [stmtRv?, isParsed]
gofi @no_parse                  # [stmtRv]
Pfld :_Parsed element           # [stmtRv, s]
svar 2                          # [stmtRv]
pfld :_Parsed remainingTokens   # [stmtRv.tail]
svar 0                          # []
pvar 2                          # [s]
pvar 1                          # [s, statements]
call ConsList:Cons Cons         # [Cons(~)]
svar 1                          # []
goto @loop_top                  # []
labl @no_parse_1                # [x]
pop                             # []
labl @no_parse                  # []
call :NoParse NoParse           # [NoParse]
rtrn

FUNC : parseStatement 1 1 0
# $0: toks
# $1: result
# $2: tmp
# $3: tmp
#
# if "return"
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @try_assignment            # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
type Lexer:KwReturn             # [toks, toks.h.isReturn]
gofi @try_assignment_1          # [toks]
pfld ConsList:Cons tail         # [toks.t]
svar 0                          # []
call Lexer:KwReturn KwReturn    # [KwR]
svar 1                          # []
goto @look_for_newline          # []
# "elif Cons(id, =, @toks)"
labl @try_assignment_1          # [x]
pop                             # []
labl @try_assignment            # []
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_parse                  # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
typf Lexer:Identifier           # [toks, toks.h?, toks.h.isId]
gofi @no_parse_1                # [toks, toks.h]
pfld Lexer:Identifier value     # [toks, toks.h.val]
svar 2                          # [toks] : $2=name
pfld ConsList:Cons tail         # [toks.t]
typf ConsList:Cons              # [toks.t?, isCons]
gofi @no_parse                  # [toks.t]
Pfld ConsList:Cons head         # [toks.t, toks.t.h]
type Lexer:Equals               # [toks.t, toks.t.h.isEquals]
gofi @no_parse_1                # [toks.t]
pfld ConsList:Cons tail         # [toks.t.t]
svar 0                          # []
pvar 0                          # [toks]
call : parseExpression          # [parseRv]
typf :_Parsed                   # [parseRv?, isParsed]
gofi @no_parse                  # [parseRv]
Pfld :_Parsed element           # [parseRv, elem]
svar 3                          # [parseRv] : $3 = expr
pfld :_Parsed remainingTokens   # [parseRv.remain]
svar 0                          # []
pvar 2                          # [name]
pvar 3                          # [name, expr]
call :EfStatAssign EfStatAssign # [EfStatAssign(~)]
svar 1                          # []
goto @look_for_newline          # []
# look for newline
labl @look_for_newline          # []
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_parse                  # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
type Denter:Newline             # [toks, toks.h.isNewline]
gofi @no_parse_1                # [toks]
pfld ConsList:Cons tail         # [toks.t]
svar 0                          # []
pvar 1                          # [s]
pvar 0                          # [s, toks]
call :_Parsed _Parsed           # [_Parsed(~)]
rtrn
labl @no_parse_1                # [x]
pop                             # []
labl @no_parse                  # []
call :NoParse NoParse           # [NoParse]
rtrn

FUNC : parseExpression 1 1 0
# $0: toks
# $1: tmp
# $2: tmp
#
# ctor
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, isCons]
gofi @no_parse                  # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
typf Lexer:TypeName             # [toks, toks.h?, isTypeName]
gofi @no_parse_1                # [toks, toks.h]
pfld Lexer:TypeName value       # [toks, toks.h.val]
svar 1                          # [toks] : $1=name
pfld ConsList:Cons tail         # [toks.t]
svar 0                          # []
call ConsList:Empty Empty       # [Empty]
svar 2                          # [] : $2=args
pvar 0                          # [toks]
call : parseArgs                # [parseArgsRv]
typf :_Parsed                   # [parseArgsRv?, isParse]
gofi @ctor_no_args              # [parseArgsRv]
Pfld :_Parsed element           # [parseArgsRv, elem]
svar 2                          # [] : $2=args
pfld :_Parsed remainingTokens   # [toks]
svar 0                          # []
labl @ctor_no_args              # []
pvar 1                          # [name]
pvar 2                          # [name, args]
call :CtorCall CtorCall         # [CtorCall(~)]
pvar 0                          # [CTorCall(~), toks]
call :_Parsed _Parsed           # [_Parsed(~)]
rtrn
labl @no_parse_1                # [x]
pop                             # []
labl @no_parse                  # []
call :NoParse NoParse           # [NoParse]
rtrn

FUNC : parseArgs 1 1 0
# $0: toks
# $1: names
# $2: name
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, toksIsCons]
gofi @no_parse-a                # [toks]
# Combine the first two "Cons" matchers, up until the cons.tail
# For the first one, we'll check if it's CloseParen. Otherwise we'll
# just bind it to $toks
#
# first Cons matcher
Pfld ConsList:Cons head         # [toks, toks.h]
type Lexer:OpenParen            # [toks, toks.h.isOpenParen]
gofi @no_parse-a-1              # [toks]
Pfld ConsList:Cons tail         # [toks, toks.t]
typf ConsList:Cons              # [toks, toks.t?, toks.t.isCons]
gofi @no_parse-a-1              # [toks, toks.t]
Pfld ConsList:Cons head         # [toks, toks.t, toks.t.h]
type Lexer:CloseParen           # [toks, toks.t, toks.t.h.isCloseParen]
gofi @if_cons_b                 # [toks, toks.t]
pfld ConsList:Cons tail         # [toks, toks.t.t]
svar 0                          # [toks]
# first Cons matched
pop                             # []
call ConsList:Empty Empty       # [Empty]
pvar 0                          # [Empty, toks]
call :_Parsed _Parsed           # [_Parsed(~)]
rtrn                            # []
# second Cons matcher
labl @if_cons_b                 # [toks, toks.t]
svar 0                          # [toks]
pop                             # []
# second Cons matched
call ConsList:Empty Empty       # [Empty]
svar 1                          # []
# "if toks is Cons(Identifier(...))
pvar 0                          # [toks]
typf ConsList:Cons              # [toks?, toksIsCons]
gofi @no_parse_b                # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
typf Lexer:Identifier           # [toks, toks.h?, toks.h.isIdentifier]
gofi @no_parse_b-1              # [toks, toks.h]
pfld Lexer:Identifier value     # [toks, toks.h.val]
svar 2                          # [toks]
pfld ConsList:Cons tail         # [toks.t]
svar 0                          # []
pvar 2                          # [name]
call ConsList:Empty Empty       # [name, Empty]
call ConsList:Cons Cons         # [Cons(name,Empty)]
svar 1                          # []
goto @after_if_b                # []
labl @no_parse_b-1              # [toks]
pop                             # []
labl @no_parse_b                # []
call :NoParse NoParse           # [NoParse]
rtrn                            # []
labl @after_if_b                # []
# "while toks is"...
labl @loop_top                  # []
pvar 0                          # [toks]
# while loop's first two Cons share the Cons check
typf ConsList:Cons              # [toks?, toksIsCons]
gofi @loop_return_noparse       # [toks]
# first check
Pfld ConsList:Cons head         # [toks, toks.h]
type Lexer:CloseParen           # [toks, toks.h.isCloseParen]
gofi @loop-second-cons          # [toks]
pfld ConsList:Cons tail         # [toks.t]
# first check matched
svar 0                          # []
pvar 1                          # [names]
svar 1                          # []
pvar 1                          # [names]
call ConsList: reverse          # [names]
pvar 0                          # [names, toks]
call :_Parsed _Parsed           # [_Parsed(~)]
rtrn
# second check
labl @loop-second-cons          # [toks]
Pfld ConsList:Cons head         # [toks, toks.h]
type Lexer:Comma                # [toks, toks.h.isComma]
gofi @loop_return_noparse-1     # [toks]
Pfld ConsList:Cons tail         # [toks, toks.t]
typf ConsList:Cons              # [toks, toks.t?, toks.t.isCons]
gofi @loop_return_noparse-1     # [toks, toks.t]
pfld ConsList:Cons head         # [toks, toks.t.h]
typf Lexer:Identifier           # [toks, toks.t.h?, toks.t.h.isIdentifier]
gofi @loop_return_noparse-1     # [toks, toks.t.h]
pfld Lexer:Identifier value     # [toks, toks.t.h.value]
svar 2                          # [toks]
pfld ConsList:Cons tail         # [toks.t]
pfld ConsList:Cons tail         # [toks.t.t]
svar 0                          # []
# second check matched
pvar 2                          # [name]
pvar 1                          # [name, names]
call ConsList:Cons Cons         # [Cons(~)]
svar 1                          # []
goto @loop_top                  # []
# while loop's NoParse
labl @loop_return_noparse-1     # [toks]
pop                             # p[
labl @loop_return_noparse       # []
call :NoParse NoParse           # [NoParse]
rtrn
# top-level NoParse
labl @no_parse-a-1              # [toks]
pop                             # []
labl @no_parse-a                # []
call :NoParse NoParse           # [NoParse]
rtrn                            # []

FUNC : main 1 1 0
call_Stream:stdin               # [stdin]
call Lexer: create              # [lexer]
call : readTokens               # [toks]
call : parseFile                # [parse]
call_native:toStringPretty      # [parseString]
call_String:sout                # []
str  "\n"                       # ["\n"]
call_String:sout                # []
int  0                          # [0]
rtrn
